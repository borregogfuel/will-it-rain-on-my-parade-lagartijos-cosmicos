<!DOCTYPE html>
<html lang="es">
<head>
    <script type="importmap">
    {
        "imports": {
            "three": "../build/three.webgpu.js",
            "three/webgpu": "../build/three.webgpu.js",
            "three/tsl": "../build/three.tsl.js",
            "three/addons/": "./jsm/"
        }
    }
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pronóstico Futurista</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; overflow: hidden; }
        #bg-canvas { position: fixed; top:0; left:0; width:100%; height:100%; z-index:0; }
        input::placeholder { color: #9ca3af; }
        .fade-in { transition: opacity 0.5s ease-in-out; }
        
        /* Weather Grid Styles */
        .weather-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin: 20px 0;
        }
        
        .weather-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .weather-icon {
            font-size: 24px;
            margin-bottom: 8px;
        }
        
        .weather-value {
            font-size: 20px;
            font-weight: bold;
            color: #60a5fa;
            margin-bottom: 4px;
        }
        
        .weather-label {
            font-size: 12px;
            color: #9ca3af;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .weather-description {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 12px;
            margin: 15px 0;
            text-align: center;
        }
        
        .data-source {
            text-align: center;
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .data-source small {
            color: #6b7280;
            font-size: 11px;
        }
        
        /* Mejoras de transición para evitar mezcla de UI */
        #main-ui {
            transition: opacity 0.3s ease-in-out;
        }
        
        #main-ui[style*="opacity: 0"] {
            pointer-events: none;
        }
        
        #loading-panel, #glass-panel {
            z-index: 100;
        }
        
        /* Estilos glassmorphism mejorados */
        .glass-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
        }
        
        .glass-input {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
        }
        
        .glass-input:focus {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(59, 130, 246, 0.5);
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.3);
        }
        
        .glass-button {
            background: rgba(59, 130, 246, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(59, 130, 246, 0.3);
            transition: all 0.3s ease;
        }
        
        .glass-button:hover {
            background: rgba(59, 130, 246, 0.9);
            box-shadow: 0 10px 30px rgba(59, 130, 246, 0.4);
            transform: translateY(-2px);
        }
    </style>
</head>
<body class="bg-black text-white">

<canvas id="bg-canvas"></canvas>

<main id="main-ui" class="relative z-10 flex flex-col items-center justify-center h-screen p-4 fade-in">
    <div class="glass-panel rounded-3xl p-8 max-w-xl w-full text-center">
        <h1 class="text-3xl md:text-5xl font-bold mb-4">Cuéntame, ¿cuál es tu plan?</h1>
        <p class="text-base md:text-lg text-gray-300 mb-6">Busca cualquier ciudad del mundo para ver el clima actual.</p>
            <form id="location-form" class="flex flex-col sm:flex-row gap-3">
            <input type="text" id="location-input" placeholder="Ej: Madrid, Barcelona, Buenos Aires, Miami..." class="glass-input w-full px-4 py-3 text-base rounded-full focus:ring-2 focus:ring-blue-400 focus:outline-none placeholder-gray-300 transition-all duration-300 text-white">
            <button type="submit" class="glass-button px-6 py-3 rounded-full text-base font-semibold transition-all duration-300 shadow-lg">Visualizar</button>
            </form>
    </div>
</main>

<!-- Panel de Loading -->
<div id="loading-panel" class="hidden fixed top-0 left-0 w-full h-full z-40 flex items-center justify-center fade-in">
    <div class="glass-panel rounded-3xl p-10 max-w-lg w-full text-white relative">
        <div class="text-center">
            <div class="mb-6">
                <div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-white"></div>
            </div>
            <h2 id="loading-title" class="text-2xl font-bold mb-4">Cargando datos del planeta...</h2>
            <p id="loading-message" class="text-lg text-gray-200 mb-6">Trazando la ruta hacia tu ciudad...</p>
            <p id="loading-detail" class="text-sm text-gray-300">Conectando con los satélites...</p>
                </div>
            </div>
        </div>

<div id="glass-panel" class="hidden fixed top-0 left-0 w-full h-full z-50 flex items-center justify-center fade-in">
    <div class="glass-panel rounded-3xl p-10 max-w-lg w-full text-white relative">
        <h2 id="glass-location" class="text-3xl font-bold mb-2 text-center"></h2>
        <p id="glass-coordinates" class="text-sm text-gray-200 mb-4 text-center"></p>
        <div id="glass-forecast" class="text-center text-lg space-y-2"></div>
        <p id="glass-gemini" class="mt-4 italic text-gray-200 text-center"></p>
        <button id="glass-close" class="glass-button mt-6 w-full px-6 py-3 rounded-full font-semibold transition-all duration-300 relative z-10">Regresar a Inicio</button>
    </div>
</div>

<script type="module">
import * as THREE from 'three';
import { step, normalWorldGeometry, output, texture, vec3, vec4, normalize, positionWorld, bumpMap, cameraPosition, color, uniform, mix, uv, max } from 'three/tsl';

let camera, scene, renderer, globe, clock, starLayers;
let targetPosition = new THREE.Vector3(0,0,5);
let forecastRequest = null;
// Estado de la animación tipo ruleta
let rouletteState = null; // { active, startTime, durationMs, initialYaw, extraSpin, targetLat, targetLon, targetLocal, resolve }
let pendingZoomTimeout = null; // id de timeout para iniciar zoom antes del fin de la ruleta

// Variables para el panel de loading
let loadingPanel = null;
let loadingTitle = null;
let loadingMessage = null;
let loadingDetail = null;

// Variables de suavidad separadas
const smoothingIn = 0.01;  // entrada lenta
const smoothingOut = 0.002; // salida lenta
const fadeDurationIn = 1000;  // ms
const fadeDurationOut = 1000; // ms

init();

function init() {
    clock = new THREE.Clock();
    camera = new THREE.PerspectiveCamera(25, window.innerWidth/window.innerHeight, 0.1, 500);
    camera.position.set(0,0,5);

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const sun = new THREE.DirectionalLight('#ffffff', 2.5);
    sun.position.set(3,0,3);
    scene.add(sun);

    const textureLoader = new THREE.TextureLoader();
    const dayTexture = textureLoader.load('./textures/planets/earth_day_4096.jpg');
    dayTexture.colorSpace = THREE.SRGBColorSpace;
    const nightTexture = textureLoader.load('./textures/planets/earth_night_4096.jpg');
    nightTexture.colorSpace = THREE.SRGBColorSpace;
    const bumpRoughnessCloudsTexture = textureLoader.load('./textures/planets/earth_bump_roughness_clouds_4096.jpg');

    const sphereGeometry = new THREE.SphereGeometry(1,64,64);
    const globeMaterial = new THREE.MeshStandardNodeMaterial();
    const cloudsStrength = texture(bumpRoughnessCloudsTexture, uv()).b.smoothstep(0.2,1);
    globeMaterial.colorNode = mix(texture(dayTexture), vec3(1), cloudsStrength.mul(2));
    const roughness = max(texture(bumpRoughnessCloudsTexture).g, step(0.01, cloudsStrength));
    globeMaterial.roughnessNode = roughness.remap(0,1,uniform(1), uniform(0.2));
    
    // Solo usar textura de día - eliminar efectos de noche
    const viewDirection = positionWorld.sub(cameraPosition).normalize();
    const fresnel = viewDirection.dot(normalWorldGeometry).abs().oneMinus().toVar();
    const atmosphereDayColor = uniform(color('#4479a2'));
    const atmosphereMix = fresnel.pow(2).clamp(0,1);
    
    // Solo textura de día + atmósfera
    let finalOutput = globeMaterial.colorNode;
    finalOutput = mix(finalOutput, atmosphereDayColor, atmosphereMix);
    globeMaterial.outputNode = vec4(finalOutput, output.a);
    
    const bumpElevation = max(texture(bumpRoughnessCloudsTexture).r, cloudsStrength);
    globeMaterial.normalNode = bumpMap(bumpElevation);
    globe = new THREE.Mesh(sphereGeometry, globeMaterial);
    scene.add(globe);

    const atmosphereMaterial = new THREE.MeshBasicNodeMaterial({side: THREE.BackSide, transparent:true});
    let alpha = fresnel.remap(0.73,1,1,0).pow(3);
    // Atmósfera siempre visible - no depende de la orientación del sol
    atmosphereMaterial.outputNode = vec4(atmosphereDayColor, alpha);
    const atmosphere = new THREE.Mesh(sphereGeometry, atmosphereMaterial);
    atmosphere.scale.setScalar(1.04);
    scene.add(atmosphere);

    function createStarField(count, radius, minSize, maxSize, speedRange){
        const positions = new Float32Array(count*3);
        const baseOpacities = new Float32Array(count);
        for(let i=0;i<count;i++){
            const u = Math.random();
            const v = Math.random();
            const theta = 2*Math.PI*u;
            const phi = Math.acos(2*v-1);
            const r = radius*(0.8 + Math.random()*0.2);
            positions[i*3] = r*Math.sin(phi)*Math.cos(theta);
            positions[i*3+1] = r*Math.sin(phi)*Math.sin(theta);
            positions[i*3+2] = r*Math.cos(phi);
            baseOpacities[i] = 0.3 + Math.random()*0.7;
        }
        const starsGeo = new THREE.BufferGeometry();
        starsGeo.setAttribute('position', new THREE.BufferAttribute(positions,3));
        const starsMat = new THREE.PointsMaterial({
            size:1,
            color:0xffffff,
            transparent:true,
            opacity:0.8,
            depthWrite:false,
            blending:THREE.AdditiveBlending
        });
        const points = new THREE.Points(starsGeo, starsMat);
        points.userData = {speed: speedRange[0] + Math.random()*(speedRange[1]-speedRange[0]), baseOpacities};
        scene.add(points);
        return points;
    }

    starLayers = [
        createStarField(12000,120,0.5,1.2,[0.5,0.8]),
        createStarField(10000,130,0.8,1.5,[0.7,1.0]),
        createStarField(8000,140,1.0,2.0,[0.9,1.3])
    ];

    renderer = new THREE.WebGPURenderer({canvas:document.querySelector('#bg-canvas'), antialias:true});
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setAnimationLoop(animate);
}

// Funciones para el panel de loading
function showLoadingPanel(cityName) {
    loadingPanel = document.getElementById('loading-panel');
    loadingTitle = document.getElementById('loading-title');
    loadingMessage = document.getElementById('loading-message');
    loadingDetail = document.getElementById('loading-detail');
    
    // Asegurar que la UI principal esté completamente oculta
    mainUI.style.opacity = '0';
    mainUI.style.pointerEvents = 'none'; // Deshabilitar interacciones
    
    // Mensajes dinámicos basados en la ciudad
    const messages = getLoadingMessages(cityName);
    
    loadingTitle.textContent = messages.title;
    loadingMessage.textContent = messages.message;
    loadingDetail.textContent = messages.detail;
    
    // Mostrar panel
    loadingPanel.classList.remove('hidden');
    loadingPanel.style.transition = `opacity ${fadeDurationIn}ms ease-in-out`;
    loadingPanel.style.opacity = '0';
    setTimeout(() => {
        loadingPanel.style.opacity = '1';
    }, 10);
    
    // Iniciar mensajes dinámicos
    startLoadingProgress();
}

function getLoadingMessages(cityName) {
    const cityDisplayName = capitalizeCityName(cityName);
    
    const messageSets = [
        // Mensajes de inicio - Exploración espacial
        {
            title: "🚀 Iniciando secuencia de lanzamiento...",
            message: "Despegando hacia el espacio...",
            detail: "Activando propulsores principales..."
        },
        {
            title: "🌍 Escaneando la Tierra desde el espacio...",
            message: "Localizando tu destino en el planeta...",
            detail: "Satélites GPS sincronizados ✅"
        },
        {
            title: "🛰️ Conectando con la red de satélites...",
            message: "Estableciendo comunicación orbital...",
            detail: "Señal fuerte desde la Estación Espacial Internacional"
        },
        
        // Mensajes de navegación - Viaje
        {
            title: "🧭 Calculando trayectoria óptima...",
            message: `Navegando hacia ${cityDisplayName}...`,
            detail: "Evitando tormentas espaciales..."
        },
        {
            title: "⚡ Activando motores de crucero...",
            message: `Viajando a velocidad warp hacia ${cityDisplayName}...`,
            detail: "Velocidad: 28,000 km/h"
        },
        {
            title: "🌌 Cruzando el espacio-tiempo...",
            message: `Teletransportándonos a ${cityDisplayName}...`,
            detail: "Distorsión temporal: 0.003 segundos"
        },
        {
            title: "🎯 Ajustando coordenadas precisas...",
            message: `Apuntando hacia ${cityDisplayName}...`,
            detail: "Precisión: ±0.001 grados"
        },
        
        // Mensajes de análisis - Datos
        {
            title: "📡 Descargando datos meteorológicos...",
            message: `Analizando clima de ${cityDisplayName}...`,
            detail: "Procesando 2.3 TB de información..."
        },
        {
            title: "🌡️ Escaneando patrones climáticos...",
            message: `Estudiando la atmósfera de ${cityDisplayName}...`,
            detail: "IA meteorológica trabajando..."
        },
        {
            title: "☁️ Mapeando sistemas de nubes...",
            message: `Observando el cielo de ${cityDisplayName}...`,
            detail: "Resolución: 4K ultra HD"
        },
        {
            title: "🌪️ Detectando corrientes de aire...",
            message: `Monitoreando vientos en ${cityDisplayName}...`,
            detail: "Sensores ultrasónicos activos"
        },
        
        // Mensajes de preparación - Finalización
        {
            title: "🎬 Preparando vista cinematográfica...",
            message: `Optimizando visualización de ${cityDisplayName}...`,
            detail: "Renderizando en tiempo real..."
        },
        {
            title: "✨ Aplicando efectos especiales...",
            message: `Pulindo la vista de ${cityDisplayName}...`,
            detail: "Filtros atmosféricos activados"
        },
        {
            title: "🎯 Enfocando objetivo principal...",
            message: `Centrando cámara en ${cityDisplayName}...`,
            detail: "Estabilización óptica completa"
        },
        {
            title: "🚀 Preparando aterrizaje suave...",
            message: `Descendiendo hacia ${cityDisplayName}...`,
            detail: "Tren de aterrizaje desplegado"
        },
        
        // Mensajes especiales por ciudad
        {
            title: "🗼 Escaneando la Torre Eiffel...",
            message: "París detectada en el horizonte...",
            detail: "Señal de croissants frescos recibida 🥐"
        },
        {
            title: "🏰 Localizando el Big Ben...",
            message: "Londres identificada por su acento...",
            detail: "Té de las 5 en punto confirmado ☕"
        },
        {
            title: "🗾 Detectando el Monte Fuji...",
            message: "Tokio localizada por su tecnología...",
            detail: "Robots de servicio activos 🤖"
        },
        {
            title: "🗽 Escaneando la Estatua de la Libertad...",
            message: "Nueva York identificada por su energía...",
            detail: "Taxi amarillo detectado 🚕"
        },
        {
            title: "🏛️ Localizando las pirámides...",
            message: "El Cairo encontrado en el desierto...",
            detail: "Momias verificando datos 📜"
        },
        {
            title: "🏖️ Detectando playas de Copacabana...",
            message: "Río de Janeiro localizada por su samba...",
            detail: "Carnaval en modo standby 🎭"
        },
        {
            title: "🌮 Escaneando tacos auténticos...",
            message: "Ciudad de México identificada...",
            detail: "Salsa picante nivel máximo 🌶️"
        },
        {
            title: "🦘 Detectando canguros saltarines...",
            message: "Sídney localizada en Oceanía...",
            detail: "Opera House sintonizada 🎭"
        }
    ];
    
    // Filtrar mensajes específicos de la ciudad si existen
    const citySpecificMessages = messageSets.filter(msg => 
        msg.message.includes(cityDisplayName) || 
        msg.title.toLowerCase().includes(cityName.toLowerCase())
    );
    
    // Si hay mensajes específicos de la ciudad, usar uno de esos
    if (citySpecificMessages.length > 0) {
        return citySpecificMessages[Math.floor(Math.random() * citySpecificMessages.length)];
    }
    
    // Si no, usar cualquier mensaje aleatorio
    return messageSets[Math.floor(Math.random() * messageSets.length)];
}

function capitalizeCityName(cityName) {
    const cityMap = {
        'tokio': 'Tokio',
        'paris': 'París',
        'londres': 'Londres',
        'new york': 'Nueva York',
        'sydney': 'Sídney',
        'el cairo': 'El Cairo',
        'rio de janeiro': 'Río de Janeiro',
        'mexico': 'Ciudad de México'
    };
    
    return cityMap[cityName.toLowerCase()] || cityName.charAt(0).toUpperCase() + cityName.slice(1);
}

function startLoadingProgress() {
    // Cambiar mensajes dinámicamente durante la carga
    const messageChangeInterval = 2000; // Cambiar cada 2 segundos
    
    // Cambiar mensajes dinámicamente
    const messageTimer = setInterval(() => {
        if (loadingTitle && loadingMessage && loadingDetail) {
            const currentCity = forecastRequest ? forecastRequest.city : "tokio";
            const newMessages = getLoadingMessages(currentCity);
            
            // Animación de fade out/in para cambio suave
            loadingTitle.style.transition = "opacity 0.3s ease";
            loadingMessage.style.transition = "opacity 0.3s ease";
            loadingDetail.style.transition = "opacity 0.3s ease";
            
            loadingTitle.style.opacity = "0";
            loadingMessage.style.opacity = "0";
            loadingDetail.style.opacity = "0";
            
            setTimeout(() => {
                loadingTitle.textContent = newMessages.title;
                loadingMessage.textContent = newMessages.message;
                loadingDetail.textContent = newMessages.detail;
                
                loadingTitle.style.opacity = "1";
                loadingMessage.style.opacity = "1";
                loadingDetail.style.opacity = "1";
            }, 300);
        }
    }, messageChangeInterval);
    
    // Limpiar el timer cuando se oculte el panel
    window.currentMessageTimer = messageTimer;
}


function hideLoadingPanel() {
    if (loadingPanel) {
        loadingPanel.style.transition = `opacity ${fadeDurationOut}ms ease-in-out`;
        loadingPanel.style.opacity = '0';
        setTimeout(() => {
            loadingPanel.classList.add('hidden');
            // Limpiar solo el timer de mensajes, el progreso se maneja con requestAnimationFrame
            if (window.currentMessageTimer) {
                clearInterval(window.currentMessageTimer);
                window.currentMessageTimer = null;
            }
        }, fadeDurationOut);
    }
}

function onWindowResize(){
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate(){
    const delta = clock.getDelta();
    // Ruleta: si está activa, controla la rotación Y del globo
    if(rouletteState && rouletteState.active){
        const now = performance.now();
        const t = Math.min(1, (now - rouletteState.startTime) / rouletteState.durationMs);
        // Ease-out cúbico para salida rápida inicial y desaceleración progresiva
        const easeOutCubic = (u)=> 1 - Math.pow(1 - u, 3);
        const f = easeOutCubic(t);

        // Giro base con vueltas extra
        const baseYaw = rouletteState.initialYaw + rouletteState.extraSpin * f;

        // Rotación simple: solo las vueltas de ruleta, sin alineación compleja
        globe.rotation.y = baseYaw;
        if(t >= 1){
            rouletteState.active = false;
            // Termina la animación con la rotación final
            globe.rotation.y = baseYaw;
            const res = rouletteState.resolve; rouletteState.resolve = null;
            if(res) res();
        }
    } else if(!forecastRequest) {
        globe.rotation.y += delta*0.1;
    }

    // Elegir suavidad según el estado
    const smoothing = forecastRequest ? smoothingIn : smoothingOut;
    camera.position.lerp(targetPosition, smoothing);
    camera.lookAt(0,0,0);

    const time = Date.now()*0.001;
    starLayers.forEach(layer=>{
        const base = layer.userData.baseOpacities;
        const avgOpacity = base.reduce((sum,b)=>sum+b*(0.7+0.3*Math.sin(time*layer.userData.speed+Math.random()*Math.PI)),0)/base.length;
        layer.material.opacity = avgOpacity;
    });

    renderer.render(scene,camera);
}

// --- UI ---
const form = document.getElementById('location-form');
const input = document.getElementById('location-input');
const mainUI = document.getElementById('main-ui');
const glassPanel = document.getElementById('glass-panel');
const glassClose = document.getElementById('glass-close');

const sampleBackendData = {
    city:'París', lat:48.8566, lon:2.3522,
    temperature:18, precipitation:30,
    gemini:'Tendencia a cielos despejados en las próximas horas.'
};

function showGlassPanel(data, timeInfo = null){
    document.getElementById('glass-location').textContent = data.city;
    document.getElementById('glass-coordinates').textContent = `Lat: ${data.lat.toFixed(4)}, Lon: ${data.lon.toFixed(4)}`;
    
    // Enhanced weather display with real-time data
    let forecastHTML = `
        <div class="weather-grid">
            <div class="weather-item">
                <div class="weather-icon">🌡️</div>
                <div class="weather-value">${data.temperature}°C</div>
                <div class="weather-label">Temperatura</div>
            </div>
            <div class="weather-item">
                <div class="weather-icon">💧</div>
                <div class="weather-value">${data.humidity || 'N/A'}%</div>
                <div class="weather-label">Humedad</div>
            </div>
            <div class="weather-item">
                <div class="weather-icon">🌧️</div>
                <div class="weather-value">${data.precipitation}%</div>
                <div class="weather-label">Precipitación</div>
            </div>
            <div class="weather-item">
                <div class="weather-icon">💨</div>
                <div class="weather-value">${data.windSpeed || 'N/A'} m/s</div>
                <div class="weather-label">Viento</div>
            </div>
        </div>
        <div class="weather-description">
            <strong>Condiciones:</strong> ${data.description || 'Datos no disponibles'}
        </div>
        <div class="data-source">
            <small>${data.apiStatus === 'real' ? '✅ Datos en tiempo real de OpenWeatherMap' : '⚠️ Datos de respaldo (API no disponible)'}</small>
        </div>
    `;
    
    document.getElementById('glass-forecast').innerHTML = forecastHTML;
    
    // Format Gemini interpretation with time information
    let geminiText = data.gemini;
    if (timeInfo) {
        const timeText = formatTimeInSpanish(timeInfo);
        const locationName = data.city || 'esta ubicación';
        geminiText = `Pronóstico del tiempo ${timeText} para ${locationName}: ${data.gemini}`;
    } else {
        // If no time specified, use "Diagnóstico actual"
        const locationName = data.city || 'esta ubicación';
        geminiText = `Diagnóstico actual para ${locationName}: ${data.gemini}`;
    }
    document.getElementById('glass-gemini').textContent = `Interpretación Gemini: ${geminiText}`;
    
    glassPanel.classList.remove('hidden');
    glassPanel.style.transition = `opacity ${fadeDurationIn}ms ease-in-out`;
    glassPanel.style.opacity='0';
    setTimeout(()=>{glassPanel.style.opacity='1';},10);
}

glassClose.addEventListener('click', () => {
    glassPanel.style.transition = `opacity ${fadeDurationOut}ms ease-in-out`;
    glassPanel.style.opacity='0';
    mainUI.style.opacity = '1';
    mainUI.style.pointerEvents = 'auto'; // Restaurar interacciones
    forecastRequest = null;
    targetPosition.set(0,0,5);
    setTimeout(()=> glassPanel.classList.add('hidden'), fadeDurationOut);
});

const cityCoordinates = {
    'tokio':{lat:35.6762, lon:139.6503},
    'paris':{lat:48.8566, lon:2.3522},
    'londres':{lat:51.5074, lon:-0.1278},
    'new york':{lat:40.7128, lon:-74.0060},
    'sydney':{lat:-33.8688, lon:151.2093},
    'el cairo':{lat:30.0444, lon:31.2357},
    'rio de janeiro':{lat:-22.9068, lon:-43.1729},
    'mexico':{lat:19.4326, lon:-99.1332}
};

// Function to format time information in Spanish
function formatTimeInSpanish(timeInfo) {
    if (!timeInfo) return '';
    
    const { type, value, original } = timeInfo;
    
    switch (type) {
        case 'days':
            if (value === 1) return 'en 1 día';
            return `en ${value} días`;
            
        case 'weeks':
            if (value === 1) return 'en 1 semana';
            return `en ${value} semanas`;
            
        case 'months':
            if (value === 1) return 'en 1 mes';
            return `en ${value} meses`;
            
        case 'years':
            if (value === 1) return 'en 1 año';
            return `en ${value} años`;
            
        case 'tomorrow':
            return 'mañana';
            
        case 'today':
            return 'hoy';
            
        case 'next_month':
            return 'el próximo mes';
            
        case 'next_week':
            return 'la próxima semana';
            
        case 'soon':
            return 'pronto';
            
        case 'later':
            return 'después';
            
        default:
            return original || '';
    }
}

// Function to extract both location and time from user input
function extractLocationAndTime(text) {
    // Convert to lowercase for easier matching
    const lowerText = text.toLowerCase();
    
    // List of time-related words and patterns
    const timePatterns = [
        // Days
        { pattern: /(\d+)\s*días?/i, type: 'days', value: (match) => parseInt(match[1]) },
        { pattern: /(\d+)\s*d/i, type: 'days', value: (match) => parseInt(match[1]) },
        
        // Weeks
        { pattern: /(\d+)\s*semanas?/i, type: 'weeks', value: (match) => parseInt(match[1]) },
        { pattern: /(\d+)\s*s/i, type: 'weeks', value: (match) => parseInt(match[1]) },
        
        // Months
        { pattern: /(\d+)\s*meses?/i, type: 'months', value: (match) => parseInt(match[1]) },
        { pattern: /(\d+)\s*m/i, type: 'months', value: (match) => parseInt(match[1]) },
        
        // Years
        { pattern: /(\d+)\s*años?/i, type: 'years', value: (match) => parseInt(match[1]) },
        { pattern: /(\d+)\s*a/i, type: 'years', value: (match) => parseInt(match[1]) },
        
        // Specific time words
        { pattern: /mañana/i, type: 'tomorrow', value: () => 1 },
        { pattern: /hoy/i, type: 'today', value: () => 0 },
        { pattern: /próximo\s*mes/i, type: 'next_month', value: () => 1 },
        { pattern: /siguiente\s*mes/i, type: 'next_month', value: () => 1 },
        { pattern: /próxima\s*semana/i, type: 'next_week', value: () => 1 },
        { pattern: /siguiente\s*semana/i, type: 'next_week', value: () => 1 },
        { pattern: /pronto/i, type: 'soon', value: () => 3 },
        { pattern: /después/i, type: 'later', value: () => 7 }
    ];
    
    // Find time information
    let timeInfo = null;
    for (const timePattern of timePatterns) {
        const match = text.match(timePattern.pattern);
        if (match) {
            timeInfo = {
                type: timePattern.type,
                value: timePattern.value(match),
                original: match[0]
            };
            break;
        }
    }
    
    // Extract location (same logic as before)
    const location = extractLocationFromText(text);
    
    return {
        location: location,
        time: timeInfo
    };
}

// Function to extract city/country from user input
function extractLocationFromText(text) {
    // Convert to lowercase for easier matching
    const lowerText = text.toLowerCase();
    
    // List of common time-related words to ignore
    const timeWords = [
        'en', 'dentro de', 'para', 'el', 'la', 'los', 'las',
        'días', 'día', 'semanas', 'semana', 'meses', 'mes', 'años', 'año',
        'mañana', 'hoy', 'ayer', 'pasado', 'próximo', 'siguiente',
        'futuro', 'pronto', 'después', 'luego', 'cuando', 'si',
        'voy', 'iré', 'estaré', 'visitaré', 'viajaré', 'ir', 'estar',
        'visitar', 'viajar', 'quiero', 'necesito', 'busco', 'buscar',
        'pronóstico', 'clima', 'tiempo', 'weather', 'forecast',
        'cuál', 'como', 'está', 'será', 'estará', 'hace', 'hará',
        'quiero', 'necesito', 'busco', 'buscar', 'ver', 'mirar',
        'saber', 'conocer', 'información', 'datos', 'estado',
        'condiciones', 'temperatura', 'lluvia', 'sol', 'nubes'
    ];
    
    // Remove common punctuation
    let cleanText = text.replace(/[.,!?;:()]/g, ' ');
    
    // Split into words and filter out time-related words
    let words = cleanText.toLowerCase().split(/\s+/)
        .filter(word => word.length > 0)
        .filter(word => !timeWords.includes(word))
        .filter(word => !/^\d+$/.test(word)) // Remove pure numbers
        .filter(word => !['de', 'del', 'la', 'el', 'los', 'las', 'un', 'una'].includes(word)); // Remove articles
    
    // Try to find city/country patterns
    let location = '';
    
    // Pattern 1: Single word (likely city name)
    if (words.length === 1) {
        location = words[0];
    }
    // Pattern 2: Two words (likely "City Country" or "City State")
    else if (words.length === 2) {
        location = words.join(' ');
    }
    // Pattern 3: Multiple words - try to find the most likely location
    else if (words.length > 2) {
        // Look for common city/country patterns
        const patterns = [
            // "Ciudad, País" pattern
            /^([^,]+),\s*(.+)$/,
            // "Ciudad País" pattern
            /^(.+?)\s+(.+)$/
        ];
        
        let found = false;
        for (const pattern of patterns) {
            const match = text.match(pattern);
            if (match) {
                location = match[1].trim();
                found = true;
                break;
            }
        }
        
        // If no pattern found, try to extract the first meaningful words
        if (!found) {
            // Take first 1-2 words that are likely location names
            const meaningfulWords = words.filter(word => 
                word.length > 2 && // At least 3 characters
                !['con', 'para', 'por', 'desde', 'hasta', 'entre'].includes(word)
            );
            
            if (meaningfulWords.length >= 2) {
                location = meaningfulWords.slice(0, 2).join(' ');
            } else if (meaningfulWords.length === 1) {
                location = meaningfulWords[0];
            } else {
                location = words.slice(0, 2).join(' ');
            }
        }
    }
    
    // Clean up the location
    location = location.trim();
    
    // Handle special cases for multi-word cities
    const specialCases = {
        'buenos aires': 'Buenos Aires',
        'nueva york': 'New York',
        'los angeles': 'Los Angeles',
        'san francisco': 'San Francisco',
        'las vegas': 'Las Vegas',
        'rio de janeiro': 'Rio de Janeiro',
        'sao paulo': 'Sao Paulo',
        'el cairo': 'Cairo',
        'san diego': 'San Diego',
        'san antonio': 'San Antonio',
        'santa fe': 'Santa Fe',
        'la paz': 'La Paz',
        'san jose': 'San Jose',
        'santa cruz': 'Santa Cruz',
        'san miguel': 'San Miguel',
        'santa rosa': 'Santa Rosa',
        'san luis': 'San Luis',
        'santa marta': 'Santa Marta',
        'san salvador': 'San Salvador',
        'santa clara': 'Santa Clara'
    };
    
    // Check for special cases first
    const lowerLocation = location.toLowerCase();
    if (specialCases[lowerLocation]) {
        location = specialCases[lowerLocation];
    } else {
        // Capitalize properly for regular cases
        location = location.split(' ').map(word => 
            word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
        ).join(' ');
    }
    
    console.log(`🔍 Extracted location from "${text}": "${location}"`);
    return location;
}

// Geocoding function to convert any location text to coordinates
async function geocodeLocation(query) {
    try {
    const apiKey = (typeof window !== 'undefined' && window.__ENV__ && window.__ENV__.OPENWEATHER_API_KEY) || '';
        const response = await fetch(`https://api.openweathermap.org/geo/1.0/direct?q=${encodeURIComponent(query)}&limit=1&appid=${apiKey}`);
        
        if (!response.ok) {
            throw new Error(`Geocoding API Error: ${response.status}`);
        }
        
        const data = await response.json();
        console.log('🌍 Geocoding result:', data);
        
        if (data && data.length > 0) {
            return {
                lat: data[0].lat,
                lon: data[0].lon,
                name: data[0].name,
                country: data[0].country,
                state: data[0].state
            };
        } else {
            throw new Error('Location not found');
        }
    } catch (error) {
        console.log('⚠️ Geocoding failed:', error.message);
        return null;
    }
}

form.addEventListener('submit', async (e) => {
    e.preventDefault();
    const query = input.value.trim();
    if (!query) return;
    
    // Extract both location and time from the user's text
    const extractedData = extractLocationAndTime(query);
    const extractedLocation = extractedData.location;
    const timeInfo = extractedData.time;
    
    console.log(`📍 Original query: "${query}"`);
    console.log(`📍 Extracted location: "${extractedLocation}"`);
    console.log(`⏰ Extracted time:`, timeInfo);
    
    // Try to find in predefined cities first (for faster response)
    const foundCity = Object.keys(cityCoordinates).find(city => 
        extractedLocation.toLowerCase().includes(city) || 
        city.includes(extractedLocation.toLowerCase())
    );
    
    let locationData;
    if (foundCity) {
        // Use predefined coordinates for known cities
        const { lat, lon } = cityCoordinates[foundCity];
        locationData = { lat, lon, name: foundCity };
        console.log('📍 Using predefined coordinates for:', foundCity);
    } else {
        // Use geocoding API for any other location
        console.log('🔍 Searching for location:', extractedLocation);
        locationData = await geocodeLocation(extractedLocation);
        
        if (!locationData) {
            alert('No se pudo encontrar esa ubicación. Intenta con otro nombre.');
            return;
        }
    }
    
    // Limpia cualquier timeout previo
    if (pendingZoomTimeout) { 
        clearTimeout(pendingZoomTimeout); 
        pendingZoomTimeout = null; 
    }

        const durationMs = 10000; // 10 segundos para dar tiempo al backend
    // Inicia ruleta PRIMERO
    const p = startRouletteAnimation(locationData.lat, locationData.lon, { durationMs, extraTurns: 6 });
    
    // MOSTRAR panel de loading DESPUÉS de iniciar la ruleta (para sincronización)
    setTimeout(() => {
        showLoadingPanel(locationData.name);
    }, 100); // Aumentado el delay para asegurar transición limpia
    
        // Inicia zoom ~2.5s antes del fin para un enlace más suave
        const earlyMs = 2500;
    pendingZoomTimeout = setTimeout(() => {
            pendingZoomTimeout = null;
        hideLoadingPanel(); // Ocultar panel de loading
        zoomToLocation(locationData.lat, locationData.lon, locationData.name, timeInfo);
        }, Math.max(0, durationMs - earlyMs));
    p.then(() => { /* no-op: zoom ya disparado antes */ });
    forecastRequest = { city: locationData.name, query };
    
    // Ocultar UI principal inmediatamente
    mainUI.style.opacity = '0';
});

// Texture alignment offset - ajusta este valor para que coincida con tu textura de la Tierra
// Offset correcto encontrado: 90° - México aparece en Norteamérica, Tokyo en Japón
let earthYawOffsetDeg = -240; // Offset correcto que funciona
function latLonToVector3(lat, lon, radius){
    // Conversión estándar con offset de textura: lon=0°(+offset) hacia +Z
    const latRad = lat * Math.PI / 180;
    const lonRad = (lon + earthYawOffsetDeg) * Math.PI / 180;
    const cosLat = Math.cos(latRad);
    return new THREE.Vector3(
        radius * cosLat * Math.sin(lonRad), // X
        radius * Math.sin(latRad),          // Y
        radius * cosLat * Math.cos(lonRad)  // Z
    );
}

// Fetch real-time weather data
async function fetchWeatherData(lat, lon) {
    try {
        // Using OpenWeatherMap API (free tier) - replace with your API key
        const apiKey = (typeof window !== 'undefined' && window.__ENV__ && window.__ENV__.OPENWEATHER_API_KEY) || '';
        if (!apiKey) {
            console.warn('OpenWeatherMap API key is not set. Set window.__ENV__.OPENWEATHER_API_KEY or use a .env / hosting secret. Falling back to local mock data.');
        }
        const response = await fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=${apiKey}&units=metric`);
        
        if (!response.ok) {
            throw new Error(`API Error: ${response.status}`);
        }
        
        const data = await response.json();
        console.log('✅ Datos reales obtenidos de OpenWeatherMap:', data);
        
        return {
            temperature: Math.round(data.main.temp),
            precipitation: data.rain ? Math.round(data.rain['1h'] || 0) : 0,
            description: data.weather[0].description,
            humidity: data.main.humidity,
            windSpeed: Math.round(data.wind.speed * 10) / 10, // Round to 1 decimal
            apiStatus: 'real'
        };
    } catch (error) {
        console.log('⚠️ Usando datos de respaldo:', error.message);
        // Fallback to realistic random data based on location
        const baseTemp = lat > 0 ? 20 : 15; // Northern hemisphere warmer
        const seasonalVariation = Math.sin(Date.now() / (365.25 * 24 * 60 * 60 * 1000)) * 10;
        return {
            temperature: Math.round(baseTemp + seasonalVariation + (Math.random() - 0.5) * 10),
            precipitation: Math.round(Math.random() * 80),
            description: ['clear sky', 'few clouds', 'scattered clouds', 'broken clouds', 'shower rain'][Math.floor(Math.random() * 5)],
            humidity: Math.round(40 + Math.random() * 40),
            windSpeed: Math.round(Math.random() * 15),
            apiStatus: 'fallback'
        };
    }
}

async function zoomToLocation(lat, lon, cityName, timeInfo = null){
    const target3D = latLonToVector3(lat, lon, 1);
    
    // Aplica la rotación actual del globo al punto objetivo
    const rotatedTarget = rotateXZByYaw(target3D, globe.rotation.y);
    
    // Posiciona la cámara relativa al punto objetivo rotado con menos zoom
    const cameraOffset = rotatedTarget.clone().normalize().multiplyScalar(2); // Aumentado de 2.5 a 3.5 para menos zoom
    targetPosition.copy(cameraOffset);
    
    // Fetch real-time weather data
    const weatherData = await fetchWeatherData(lat, lon);
    
    // Create dynamic data based on the searched city with real weather
    const dynamicData = {
        city: cityName,
        lat: lat,
        lon: lon,
        temperature: weatherData.temperature,
        precipitation: weatherData.precipitation,
        humidity: weatherData.humidity,
        windSpeed: weatherData.windSpeed,
        description: weatherData.description,
        apiStatus: weatherData.apiStatus,
        gemini: `${weatherData.description}, temperatura ${weatherData.temperature}°C, humedad ${weatherData.humidity}%.`
    };
    
    showGlassPanel(dynamicData, timeInfo);
}

window.addEventListener('resize', onWindowResize);

// ---------------------------
// Animación tipo ruleta (API)
// ---------------------------
// Calcula el ángulo azimutal (XZ) de un vector
function getAzimuthXZ(v){
    return Math.atan2(v.x, v.z);
}

// Aplica rotación Y a un vector (solo XZ)
function rotateXZByYaw(vec, yaw){
    const c = Math.cos(yaw), s = Math.sin(yaw);
    return new THREE.Vector3(
        vec.x * c + vec.z * s,
        vec.y,
        -vec.x * s + vec.z * c
    );
}

// Normaliza ángulo a [-PI, PI]
function normalizeAngleSigned(a){
    let ang = (a + Math.PI) % (2*Math.PI);
    if(ang < 0) ang += 2*Math.PI;
    return ang - Math.PI;
}

// Convierte a [0, 2PI)
function normalizeAnglePositive(a){
    let ang = a % (2*Math.PI);
    if(ang < 0) ang += 2*Math.PI;
    return ang;
}

// Inicia la animación de ruleta hasta una lat/lon objetivo
// options: { durationMs=7000, extraTurns=6, direction='auto'|'cw'|'ccw' }
function startRouletteAnimation(targetLat, targetLon, options={}){
    const durationMs = options.durationMs ?? 7000;
    const extraTurns = Math.max(0, options.extraTurns ?? 6);
    const direction = options.direction ?? 'auto'; // 'cw' => +Y, 'ccw' => -Y

    // Cancela/resolve una animación previa si existiese
    if(rouletteState && rouletteState.active && rouletteState.resolve){
        const prevResolve = rouletteState.resolve; rouletteState.active = false; rouletteState.resolve = null; prevResolve();
    }

    // Punto objetivo en el globo (sin rotación aplicada)
    const targetPointLocal = latLonToVector3(targetLat, targetLon, 1);

    // Azimut deseado: usa la orientación real de la cámara
    const viewDir = new THREE.Vector3().copy(camera.position).normalize().multiplyScalar(-1); // hacia -camera.position
    const desiredAzimuth = getAzimuthXZ(viewDir);

    // Azimut actual del punto objetivo en mundo con la rotación actual del globo
    const currentYaw = globe.rotation.y;
    const targetPointWorld = rotateXZByYaw(targetPointLocal, currentYaw);
    const currentAzimuthWorld = getAzimuthXZ(targetPointWorld);

    // Diferencia mínima necesaria para alinear el punto con el azimut deseado
    const deltaToAlign = normalizeAngleSigned(desiredAzimuth - currentAzimuthWorld);

    // Decide el signo/dirección de giro y suma vueltas extra para efecto "ruleta"
    // SIEMPRE gira hacia la derecha (sentido horario) sin importar la distancia
    let sign = 1; // Siempre positivo = siempre hacia la derecha

    const fullTurns = extraTurns * 2 * Math.PI * sign;
    const extraSpin = fullTurns; // corrección dinámica se aplica en cada frame

    // Prepara estado
    let extResolve;
    const promise = new Promise((resolve)=>{ extResolve = resolve; });
    rouletteState = {
        active:true,
        startTime: performance.now(),
        durationMs,
        initialYaw: currentYaw,
        extraSpin,
        targetLat,
        targetLon,
        targetLocal: targetPointLocal,
        resolve: extResolve
    };

    return promise;
}

// Final offset testing based on the complete pattern
window.findPreciseOffset = function() {
    console.log("=== PRECISE OFFSET TESTING ===");
    console.log("Pattern observed:");
    console.log("- London (UK) → appearing in Russia");
    console.log("- Tokyo (Japan) → appearing in Mexico");
    console.log("This suggests ~90-120° rotation needed");
    
    // Test more precise offsets around the likely range
    const offsets = [90, 100, 110, 120, 130, -90, -100, -110, -120, -130];
    let currentIndex = 0;
    
    function testNext() {
        if (currentIndex >= offsets.length) {
            console.log("All precise offsets tested. Which one shows London in UK and Tokyo in Japan?");
            return;
        }
        
        const offset = offsets[currentIndex];
        console.log(`\n=== Testing precise offset: ${offset}° ===`);
        testTextureOffset(offset, "londres");
        
        currentIndex++;
        setTimeout(testNext, 4000); // Wait 4 seconds between tests
    }
    
    testNext();
};

// Quick test function to find the right offset
window.findCorrectOffset = function() {
    console.log("Testing different offsets for London...");
    console.log("London should appear in the UK (Europe), not in the US");
    
    const offsets = [0, 90, -90, 180, -180, 270, -270];
    let currentIndex = 0;
    
    function testNext() {
        if (currentIndex >= offsets.length) {
            console.log("All offsets tested. Which one showed London in the correct location?");
            return;
        }
        
        const offset = offsets[currentIndex];
        console.log(`\n=== Testing offset: ${offset}° ===`);
        testTextureOffset(offset, "londres");
        
        currentIndex++;
        setTimeout(testNext, 3000); // Wait 3 seconds between tests
    }
    
    testNext();
};

// Quick manual tests for common offsets
window.quickTestOffsets = function() {
    console.log("=== QUICK MANUAL TESTS ===");
    console.log("Try these common offsets manually:");
    console.log("testTextureOffset(0, 'mexico')     - No offset");
    console.log("testTextureOffset(90, 'mexico')    - 90° clockwise");
    console.log("testTextureOffset(180, 'mexico')   - 180° clockwise");
    console.log("testTextureOffset(270, 'mexico')   - 270° clockwise");
    console.log("testTextureOffset(-90, 'mexico')   - 90° counter-clockwise");
    console.log("testTextureOffset(-180, 'mexico')  - 180° counter-clockwise");
    console.log("testTextureOffset(-270, 'mexico')  - 270° counter-clockwise");
    console.log("\nMexico should appear in North America (left side of texture)");
};

// Systematic testing of all possible offsets
window.testAllOffsets = function() {
    console.log("=== SYSTEMATIC OFFSET TESTING ===");
    console.log("Testing every 30° from 0° to 360° to find the correct offset");
    console.log("Mexico should appear in North America, not Africa");
    
    const offsets = [0, 30, 60, 90, 120, 150, 180, 210, 240, 270, 300, 330];
    let currentIndex = 0;
    
    function testNext() {
        if (currentIndex >= offsets.length) {
            console.log("All systematic offsets tested. Which one shows Mexico in North America?");
            return;
        }
        
        const offset = offsets[currentIndex];
        console.log(`\n=== Testing systematic offset: ${offset}° ===`);
        testTextureOffset(offset, "mexico");
        
        currentIndex++;
        setTimeout(testNext, 5000); // Wait 5 seconds between tests
    }
    
    testNext();
};

// Quick test for the most likely offset based on pattern
window.testMostLikelyOffset = function() {
    console.log("Testing the most likely offset: 140°");
    console.log("This should fix:");
    console.log("- Mexico: Africa → North America");
    console.log("- Tokyo: Mexico → Japan"); 
    console.log("- London: Russia → UK");
    
    testBothCities(140);
};

// Final offset testing based on the complete pattern
window.findFinalOffset = function() {
    console.log("=== FINAL OFFSET TESTING ===");
    console.log("Complete pattern observed:");
    console.log("- Mexico (North America) → appearing in Africa");
    console.log("- Tokyo (Japan) → appearing in Mexico");
    console.log("- London (UK) → appearing in Russia");
    console.log("This suggests ~120-150° rotation needed");
    
    // Test the most likely offsets based on the pattern
    const offsets = [120, 130, 140, 150, 160, -120, -130, -140, -150, -160];
    let currentIndex = 0;
    
    function testNext() {
        if (currentIndex >= offsets.length) {
            console.log("All final offsets tested. Which one shows all cities in correct locations?");
            return;
        }
        
        const offset = offsets[currentIndex];
        console.log(`\n=== Testing final offset: ${offset}° ===`);
        testTextureOffset(offset, "mexico");
        
        currentIndex++;
        setTimeout(testNext, 4000); // Wait 4 seconds between tests
    }
    
    testNext();
};

// Test specific texture offset with a city
window.testTextureOffset = function(offsetDeg, cityName = "londres") {
    const coords = cityCoordinates[cityName.toLowerCase()];
    if (!coords) {
        console.log(`City ${cityName} not found`);
        return;
    }
    
    console.log(`Testing texture offset ${offsetDeg}° with ${cityName}`);
    
    // Temporarily set the offset
    const originalOffset = earthYawOffsetDeg;
    earthYawOffsetDeg = offsetDeg;
    
    // Reset globe rotation
    globe.rotation.y = 0;
    
    // Navigate to the city
    zoomToLocation(coords.lat, coords.lon, cityName);
    forecastRequest = {city: cityName, query: cityName};
    mainUI.style.opacity = '0';
    
    console.log(`Applied offset ${offsetDeg}°. Check if ${cityName} appears in the correct location on your texture.`);
    console.log(`To revert: adjustTextureOffset(${originalOffset})`);
};

// Test both London and Tokyo to verify the offset works for both
window.testBothCities = function(offsetDeg) {
    console.log(`Testing offset ${offsetDeg}° with both London and Tokyo`);
    
    const originalOffset = earthYawOffsetDeg;
    earthYawOffsetDeg = offsetDeg;
    globe.rotation.y = 0;
    
    // Test London first
    console.log("Testing London...");
    testTextureOffset(offsetDeg, "londres");
    
    setTimeout(() => {
        console.log("Testing Tokyo...");
        testTextureOffset(offsetDeg, "tokio");
        console.log(`\nCheck both cities: London should be in UK, Tokyo should be in Japan`);
        console.log(`If both are correct, run: adjustTextureOffset(${offsetDeg})`);
    }, 3000);
};

// Comprehensive debugging function
window.debugCoordinates = function(cityName) {
    const coords = cityCoordinates[cityName.toLowerCase()];
    if (!coords) {
        console.log(`City ${cityName} not found`);
        return;
    }
    
    console.log(`=== DEBUGGING ${cityName.toUpperCase()} ===`);
    console.log(`Original coordinates: lat=${coords.lat}, lon=${coords.lon}`);
    
    // Test different texture offsets
    const offsets = [0, -90, -180, -270, 90, 180, 270];
    
    offsets.forEach(offset => {
        const testOffset = offset;
        const latRad = coords.lat * Math.PI / 180;
        const lonRad = (coords.lon + testOffset) * Math.PI / 180;
        const cosLat = Math.cos(latRad);
        const testVector = new THREE.Vector3(
            Math.cos(latRad) * Math.sin(lonRad),
            Math.sin(latRad),
            Math.cos(latRad) * Math.cos(lonRad)
        );
        
        console.log(`Offset ${testOffset}°: Vector(${testVector.x.toFixed(3)}, ${testVector.y.toFixed(3)}, ${testVector.z.toFixed(3)})`);
    });
    
    console.log(`Current globe rotation: ${globe.rotation.y.toFixed(3)} radians (${(globe.rotation.y * 180 / Math.PI).toFixed(1)}°)`);
    console.log(`Current texture offset: ${earthYawOffsetDeg}°`);
};

// Function to reset globe rotation for testing
window.resetGlobeRotation = function() {
    globe.rotation.y = 0;
    console.log('Globe rotation reset to 0');
};

// Función para probar ajustes específicos manualmente
window.testFineOffset = function(offsetDeg) {
    console.log(`Probando ajuste fino ${offsetDeg}°`);
    
    // Aplicar el offset
    earthYawOffsetDeg = offsetDeg;
    
    // Reset globo
    globe.rotation.y = 0;
    targetPosition.set(0, 0, 5);
    
    // Probar con México
    console.log("Probando México...");
    zoomToLocation(19.4326, -99.1332, "México");
    forecastRequest = {city: "mexico", query: "mexico"};
    mainUI.style.opacity = '0';
    
    console.log(`Ajuste fino ${offsetDeg}° aplicado. ¿México está en el lugar correcto?`);
};

// Función para ajustes finos del offset
window.fineTuneOffset = function() {
    console.log('=== AJUSTE FINO DEL OFFSET ===');
    console.log('Offset actual: -263°');
    console.log('Problema: Aparece un poco al oeste');
    console.log('Probando ajustes finos...');
    
    // Si está al oeste, necesitamos valores más negativos (más hacia el este)
    const fineAdjustments = [-265, -266, -267, -268, -270, -275];
    let currentIndex = 0;
    
    function testNext() {
        if (currentIndex >= fineAdjustments.length) {
            console.log('Todos los ajustes finos probados. ¿Cuál está en el lugar correcto?');
            return;
        }
        
        const offset = fineAdjustments[currentIndex];
        console.log(`\n=== Probando ajuste fino: ${offset}° ===`);
        
        // Aplicar el offset
        earthYawOffsetDeg = offset;
        
        // Reset globo
        globe.rotation.y = 0;
        targetPosition.set(0, 0, 5);
        
        // Probar con México
        console.log("Probando México...");
        zoomToLocation(19.4326, -99.1332, "México");
        forecastRequest = {city: "mexico", query: "mexico"};
        mainUI.style.opacity = '0';
        
        currentIndex++;
        setTimeout(testNext, 4000); // Esperar 4 segundos entre pruebas
    }
    
    testNext();
};

// Función para probar un offset específico manualmente
window.testOffset = function(offsetDeg) {
    console.log(`Probando offset ${offsetDeg}°`);
    
    // Aplicar el offset
    earthYawOffsetDeg = offsetDeg;
    
    // Reset globo
    globe.rotation.y = 0;
    targetPosition.set(0, 0, 5);
    
    // Probar con México
    console.log("Probando México...");
    zoomToLocation(19.4326, -99.1332, "México");
    forecastRequest = {city: "mexico", query: "mexico"};
    mainUI.style.opacity = '0';
    
    console.log(`Offset ${offsetDeg}° aplicado. ¿México aparece en Norteamérica?`);
};

// Función para ajustar el nivel de zoom
window.setZoomLevel = function(distance) {
    console.log(`Configurando distancia de zoom a ${distance}`);
    
    // Actualizar la función zoomToLocation para usar la nueva distancia
    window.zoomToLocation = function(lat, lon, cityName){
        const target3D = latLonToVector3(lat, lon, 1);
        
        // Aplica la rotación actual del globo al punto objetivo
        const rotatedTarget = rotateXZByYaw(target3D, globe.rotation.y);
        
        // Posiciona la cámara relativa al punto objetivo rotado con distancia personalizada
        const cameraOffset = rotatedTarget.clone().normalize().multiplyScalar(distance);
        targetPosition.copy(cameraOffset);
        
        // Create dynamic data based on the searched city
        const dynamicData = {
            city: cityName,
            lat: lat,
            lon: lon,
            temperature: Math.round(15 + Math.random() * 20), // Random temp between 15-35°C
            precipitation: Math.round(Math.random() * 100), // Random precipitation 0-100%
            gemini: `Pronóstico para ${cityName}: condiciones variables con tendencia a estabilizarse.`
        };
        
        showGlassPanel(dynamicData);
    };
    
    console.log(`Zoom configurado a distancia ${distance}. Prueba con una ciudad.`);
};

// Función para alternar entre modo día solamente y modo normal
window.toggleDayOnlyMode = function() {
    console.log('Modo día solamente activado - siempre usa textura de día');
    console.log('El globo ahora siempre se verá iluminado sin efectos de noche');
    console.log('Para volver al modo normal, recarga la página');
};

// Función para probar diferentes niveles de zoom
window.testZoomLevels = function() {
    console.log('=== NIVELES DE ZOOM DISPONIBLES ===');
    console.log('Distancias recomendadas:');
    console.log('- setZoomLevel(2.0) - Muy cerca (zoom máximo)');
    console.log('- setZoomLevel(2.5) - Cerca');
    console.log('- setZoomLevel(3.0) - Medio');
    console.log('- setZoomLevel(3.5) - Lejos (actual)');
    console.log('- setZoomLevel(4.0) - Muy lejos');
    console.log('- setZoomLevel(5.0) - Vista general');
    console.log('');
    console.log('Prueba con: setZoomLevel(4.0)');
};

// Función para encontrar el offset correcto automáticamente
window.findCorrectOffset = function() {
    console.log("=== BUSCANDO OFFSET CORRECTO ===");
    console.log("Problema actual:");
    console.log("- Tokyo aparece en América");
    console.log("- México aparece en África");
    console.log("Probando diferentes offsets...");
    
    const testOffsets = [0, 90, 180, 270, -90, -180, -270];
    let currentIndex = 0;
    
    function testNext() {
        if (currentIndex >= testOffsets.length) {
            console.log("Todos los offsets probados. ¿Cuál mostró las coordenadas correctas?");
            return;
        }
        
        const offset = testOffsets[currentIndex];
        console.log(`\n=== Probando offset: ${offset}° ===`);
        
        // Aplicar el offset
        earthYawOffsetDeg = offset;
        
        // Reset globo
        globe.rotation.y = 0;
        targetPosition.set(0, 0, 5);
        
        // Probar con México
        console.log("Probando México...");
        zoomToLocation(19.4326, -99.1332, "México");
        forecastRequest = {city: "mexico", query: "mexico"};
        mainUI.style.opacity = '0';
        
        currentIndex++;
        setTimeout(testNext, 5000); // Esperar 5 segundos entre pruebas
    }
    
    testNext();
};

// Función simple para probar coordenadas
window.testSimpleCoordinates = function(cityName) {
    const coords = cityCoordinates[cityName.toLowerCase()];
    if (!coords) {
        console.log(`City ${cityName} not found`);
        return;
    }
    
    console.log(`Testing simple coordinates for ${cityName}:`, coords);
    
    // Reset everything
    globe.rotation.y = 0;
    targetPosition.set(0, 0, 5);
    
    // Navigate to coordinates
    zoomToLocation(coords.lat, coords.lon, cityName);
    forecastRequest = {city: cityName, query: cityName};
    mainUI.style.opacity = '0';
    
    console.log(`Simple test for ${cityName}. Check coordinates.`);
};

// Función para probar coordenadas sin animación de ruleta
window.testCoordinatesDirect = function(cityName) {
    const coords = cityCoordinates[cityName.toLowerCase()];
    if (!coords) {
        console.log(`City ${cityName} not found`);
        return;
    }
    
    console.log(`Testing coordinates for ${cityName}:`, coords);
    
    // Reset globe rotation to 0
    globe.rotation.y = 0;
    
    // Navigate directly to coordinates
    zoomToLocation(coords.lat, coords.lon, cityName);
    forecastRequest = {city: cityName, query: cityName};
    mainUI.style.opacity = '0';
    
    console.log(`Direct navigation to ${cityName}. Check if coordinates are correct.`);
};

// Test function to navigate directly to coordinates without roulette animation
window.testDirectNavigation = function(cityName) {
    const coords = cityCoordinates[cityName.toLowerCase()];
    if (coords) {
        console.log(`Testing direct navigation to ${cityName}:`, coords);
        zoomToLocation(coords.lat, coords.lon, cityName);
        forecastRequest = {city: cityName, query: cityName};
        mainUI.style.opacity = '0';
    } else {
        console.log(`City ${cityName} not found in coordinates`);
    }
};

// Helper function to test texture alignment - call from browser console
// Usage: adjustTextureOffset(90) or adjustTextureOffset(-23.5)
window.adjustTextureOffset = function(offsetDeg) {
    earthYawOffsetDeg = offsetDeg;
    console.log(`Texture offset set to ${offsetDeg} degrees`);
    console.log('Test with a city to see if coordinates align better with texture');
};

// Helper function to get current offset
window.getTextureOffset = function() {
    console.log(`Current texture offset: ${earthYawOffsetDeg} degrees`);
    return earthYawOffsetDeg;
};

// Expone la API global sin tocar UI/cámara
window.startRouletteAnimation = startRouletteAnimation;

// Testing functions for location and time extraction
window.testLocationAndTimeExtraction = function(text) {
    const extracted = extractLocationAndTime(text);
    console.log(`Input: "${text}"`);
    console.log(`Location: "${extracted.location}"`);
    console.log(`Time:`, extracted.time);
    if (extracted.time) {
        console.log(`Formatted time: "${formatTimeInSpanish(extracted.time)}"`);
    }
    return extracted;
};

window.testTimeExtraction = function() {
    const testCases = [
        "México en 2 días",
        "Buenos Aires en 1 mes",
        "Tokio en 3 semanas",
        "París el próximo mes",
        "Londres en 5 días",
        "Nueva York mañana",
        "Sydney en 2 semanas",
        "El Cairo en 1 año",
        "Río de Janeiro pronto",
        "Madrid en 6 meses",
        "Berlín el siguiente mes",
        "Roma en 10 días",
        "Barcelona en 3 meses",
        "Amsterdam en 2 semanas",
        "Viena en 1 mes",
        "Tokyo tomorrow",
        "Paris next week",
        "London in 2 weeks",
        "Madrid", // Sin tiempo especificado
        "Barcelona" // Sin tiempo especificado
    ];
    
    console.log("🧪 Testing location and time extraction:");
    testCases.forEach(testCase => {
        const extracted = extractLocationAndTime(testCase);
        const timeText = extracted.time ? formatTimeInSpanish(extracted.time) : 'No time specified';
        
        // Show the final Gemini interpretation format
        let geminiFormat;
        if (extracted.time) {
            geminiFormat = `Pronóstico del tiempo ${timeText} para ${extracted.location}`;
        } else {
            geminiFormat = `Diagnóstico actual para ${extracted.location}`;
        }
        
        console.log(`"${testCase}" → Location: "${extracted.location}", Time: "${timeText}"`);
        console.log(`  Gemini format: "${geminiFormat}"`);
    });
};

window.testMultipleLocations = function() {
    const testCases = [
        "México en 2 días",
        "Buenos Aires en 1 mes",
        "Tokio en 3 semanas",
        "París el próximo mes",
        "Londres en 5 días",
        "Nueva York mañana",
        "Sydney en 2 semanas",
        "El Cairo en 1 año",
        "Río de Janeiro pronto",
        "Madrid en 6 meses",
        "Berlín el siguiente mes",
        "Roma en 10 días",
        "Barcelona en 3 meses",
        "Amsterdam en 2 semanas",
        "Viena en 1 mes"
    ];
    
    console.log("🧪 Testing location extraction:");
    testCases.forEach(testCase => {
        const extracted = extractLocationFromText(testCase);
        console.log(`"${testCase}" → "${extracted}"`);
    });
};

window.testLoadingPanel = function(cityName = "tokio") {
    console.log(`Probando panel de loading con mensajes dinámicos para ${cityName}`);
    showLoadingPanel(cityName);
    
    // Simular duración de carga
    setTimeout(() => {
        console.log("Panel de loading funcionando perfectamente!");
        hideLoadingPanel();
    }, 10000);
};

window.showLoading = function(cityName = "paris") {
    showLoadingPanel(cityName);
};

window.hideLoading = function() {
    hideLoadingPanel();
};

// Funciones adicionales para probar mensajes dinámicos
window.testAllCities = function() {
    const cities = ['tokio', 'paris', 'londres', 'mexico', 'new york', 'sydney', 'el cairo', 'rio de janeiro'];
    let currentIndex = 0;
    
    function testNextCity() {
        if (currentIndex >= cities.length) {
            console.log("Todas las ciudades probadas. ¡Mensajes súper dinámicos!");
            return;
        }
        
        const city = cities[currentIndex];
        console.log(`Probando mensajes dinámicos para ${city}...`);
        showLoadingPanel(city);
        
        currentIndex++;
    setTimeout(() => {
        hideLoadingPanel();
            setTimeout(testNextCity, 1000);
        }, 5000);
    }
    
    testNextCity();
};

window.testRandomMessages = function(cityName = "tokio") {
    console.log(`Probando mensajes aleatorios para ${cityName}`);
    console.log("Los mensajes cambiarán cada 2 segundos automáticamente");
    showLoadingPanel(cityName);
    
    setTimeout(() => {
        console.log("Mensajes dinámicos funcionando perfectamente!");
    hideLoadingPanel();
    }, 10000);
};
</script>
</body>
</html>
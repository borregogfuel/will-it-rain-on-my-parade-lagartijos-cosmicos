<!DOCTYPE html>
<html lang="es">
<head>
    <script type="importmap">
    {
        "imports": {
            "three": "../build/three.webgpu.js",
            "three/webgpu": "../build/three.webgpu.js",
            "three/tsl": "../build/three.tsl.js",
            "three/addons/": "./jsm/"
        }
    }
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pron√≥stico Futurista</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; overflow: hidden; }
        #bg-canvas { position: fixed; top:0; left:0; width:100%; height:100%; z-index:0; }
        input::placeholder { color: #9ca3af; }
        .fade-in { transition: opacity 0.5s ease-in-out; }
        
        /* Weather Grid Styles */
        .weather-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin: 20px 0;
        }
        
        .weather-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .weather-icon {
            font-size: 24px;
            margin-bottom: 8px;
        }
        
        .weather-value {
            font-size: 20px;
            font-weight: bold;
            color: #60a5fa;
            margin-bottom: 4px;
        }
        
        .weather-label {
            font-size: 12px;
            color: #9ca3af;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .weather-description {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 12px;
            margin: 15px 0;
            text-align: center;
        }
        
        .data-source {
            text-align: center;
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .data-source small {
            color: #6b7280;
            font-size: 11px;
        }
        
        /* Mejoras de transici√≥n para evitar mezcla de UI */
        #main-ui {
            transition: opacity 0.3s ease-in-out;
        }
        
        #main-ui[style*="opacity: 0"] {
            pointer-events: none;
        }
        
        #loading-panel, #glass-panel {
            z-index: 100;
        }
        
        /* Estilos glassmorphism mejorados */
        .glass-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
        }
        
        .glass-input {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
        }
        
        .glass-input:focus {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(59, 130, 246, 0.5);
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.3);
        }
        
        .glass-button {
            background: rgba(59, 130, 246, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(59, 130, 246, 0.3);
            transition: all 0.3s ease;
        }
        
        .glass-button:hover {
            background: rgba(59, 130, 246, 0.9);
            box-shadow: 0 10px 30px rgba(59, 130, 246, 0.4);
            transform: translateY(-2px);
        }
    </style>
</head>
<body class="bg-black text-white">

<canvas id="bg-canvas"></canvas>

<main id="main-ui" class="relative z-10 flex flex-col items-center justify-center h-screen p-4 fade-in">
    <div class="glass-panel rounded-3xl p-8 max-w-xl w-full text-center">
        <h1 class="text-3xl md:text-5xl font-bold mb-4">Cu√©ntame, ¬øcu√°l es tu plan?</h1>
        <p class="text-base md:text-lg text-gray-300 mb-6">Busca cualquier ciudad del mundo para ver el clima actual.</p>
            <form id="location-form" class="flex flex-col sm:flex-row gap-3">
            <input type="text" id="location-input" placeholder="Ej: Madrid, Barcelona, Buenos Aires, Miami..." class="glass-input w-full px-4 py-3 text-base rounded-full focus:ring-2 focus:ring-blue-400 focus:outline-none placeholder-gray-300 transition-all duration-300 text-white">
            <button type="submit" class="glass-button px-6 py-3 rounded-full text-base font-semibold transition-all duration-300 shadow-lg">Visualizar</button>
            </form>
    </div>
</main>

<!-- Panel de Loading -->
<div id="loading-panel" class="hidden fixed top-0 left-0 w-full h-full z-40 flex items-center justify-center fade-in">
    <div class="glass-panel rounded-3xl p-10 max-w-lg w-full text-white relative">
        <div class="text-center">
            <div class="mb-6">
                <div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-white"></div>
            </div>
            <h2 id="loading-title" class="text-2xl font-bold mb-4">Cargando datos del planeta...</h2>
            <p id="loading-message" class="text-lg text-gray-200 mb-6">Trazando la ruta hacia tu ciudad...</p>
            <p id="loading-detail" class="text-sm text-gray-300">Conectando con los sat√©lites...</p>
                </div>
            </div>
        </div>

<div id="glass-panel" class="hidden fixed top-0 left-0 w-full h-full z-50 flex items-center justify-center fade-in">
    <div class="glass-panel rounded-3xl p-10 max-w-lg w-full text-white relative">
        <h2 id="glass-location" class="text-3xl font-bold mb-2 text-center"></h2>
        <p id="glass-coordinates" class="text-sm text-gray-200 mb-4 text-center"></p>
        <div id="glass-forecast" class="text-center text-lg space-y-2"></div>
        <p id="glass-gemini" class="mt-4 italic text-gray-200 text-center"></p>
        <button id="glass-close" class="glass-button mt-6 w-full px-6 py-3 rounded-full font-semibold transition-all duration-300 relative z-10">Regresar a Inicio</button>
    </div>
</div>

<script type="module">
import * as THREE from 'three';
import { step, normalWorldGeometry, output, texture, vec3, vec4, normalize, positionWorld, bumpMap, cameraPosition, color, uniform, mix, uv, max } from 'three/tsl';

let camera, scene, renderer, globe, clock, starLayers;
let targetPosition = new THREE.Vector3(0,0,5);
let forecastRequest = null;
// Estado de la animaci√≥n tipo ruleta
let rouletteState = null; // { active, startTime, durationMs, initialYaw, extraSpin, targetLat, targetLon, targetLocal, resolve }
let pendingZoomTimeout = null; // id de timeout para iniciar zoom antes del fin de la ruleta

// Variables para el panel de loading
let loadingPanel = null;
let loadingTitle = null;
let loadingMessage = null;
let loadingDetail = null;

// Variables de suavidad separadas
const smoothingIn = 0.01;  // entrada lenta
const smoothingOut = 0.002; // salida lenta
const fadeDurationIn = 1000;  // ms
const fadeDurationOut = 1000; // ms

init();

function init() {
    clock = new THREE.Clock();
    camera = new THREE.PerspectiveCamera(25, window.innerWidth/window.innerHeight, 0.1, 500);
    camera.position.set(0,0,5);

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const sun = new THREE.DirectionalLight('#ffffff', 2.5);
    sun.position.set(3,0,3);
    scene.add(sun);

    const textureLoader = new THREE.TextureLoader();
    const dayTexture = textureLoader.load('./textures/planets/earth_day_4096.jpg');
    dayTexture.colorSpace = THREE.SRGBColorSpace;
    const nightTexture = textureLoader.load('./textures/planets/earth_night_4096.jpg');
    nightTexture.colorSpace = THREE.SRGBColorSpace;
    const bumpRoughnessCloudsTexture = textureLoader.load('./textures/planets/earth_bump_roughness_clouds_4096.jpg');

    const sphereGeometry = new THREE.SphereGeometry(1,64,64);
    const globeMaterial = new THREE.MeshStandardNodeMaterial();
    const cloudsStrength = texture(bumpRoughnessCloudsTexture, uv()).b.smoothstep(0.2,1);
    globeMaterial.colorNode = mix(texture(dayTexture), vec3(1), cloudsStrength.mul(2));
    const roughness = max(texture(bumpRoughnessCloudsTexture).g, step(0.01, cloudsStrength));
    globeMaterial.roughnessNode = roughness.remap(0,1,uniform(1), uniform(0.2));
    
    // Solo usar textura de d√≠a - eliminar efectos de noche
    const viewDirection = positionWorld.sub(cameraPosition).normalize();
    const fresnel = viewDirection.dot(normalWorldGeometry).abs().oneMinus().toVar();
    const atmosphereDayColor = uniform(color('#4479a2'));
    const atmosphereMix = fresnel.pow(2).clamp(0,1);
    
    // Solo textura de d√≠a + atm√≥sfera
    let finalOutput = globeMaterial.colorNode;
    finalOutput = mix(finalOutput, atmosphereDayColor, atmosphereMix);
    globeMaterial.outputNode = vec4(finalOutput, output.a);
    
    const bumpElevation = max(texture(bumpRoughnessCloudsTexture).r, cloudsStrength);
    globeMaterial.normalNode = bumpMap(bumpElevation);
    globe = new THREE.Mesh(sphereGeometry, globeMaterial);
    scene.add(globe);

    const atmosphereMaterial = new THREE.MeshBasicNodeMaterial({side: THREE.BackSide, transparent:true});
    let alpha = fresnel.remap(0.73,1,1,0).pow(3);
    // Atm√≥sfera siempre visible - no depende de la orientaci√≥n del sol
    atmosphereMaterial.outputNode = vec4(atmosphereDayColor, alpha);
    const atmosphere = new THREE.Mesh(sphereGeometry, atmosphereMaterial);
    atmosphere.scale.setScalar(1.04);
    scene.add(atmosphere);

    function createStarField(count, radius, minSize, maxSize, speedRange){
        const positions = new Float32Array(count*3);
        const baseOpacities = new Float32Array(count);
        for(let i=0;i<count;i++){
            const u = Math.random();
            const v = Math.random();
            const theta = 2*Math.PI*u;
            const phi = Math.acos(2*v-1);
            const r = radius*(0.8 + Math.random()*0.2);
            positions[i*3] = r*Math.sin(phi)*Math.cos(theta);
            positions[i*3+1] = r*Math.sin(phi)*Math.sin(theta);
            positions[i*3+2] = r*Math.cos(phi);
            baseOpacities[i] = 0.3 + Math.random()*0.7;
        }
        const starsGeo = new THREE.BufferGeometry();
        starsGeo.setAttribute('position', new THREE.BufferAttribute(positions,3));
        const starsMat = new THREE.PointsMaterial({
            size:1,
            color:0xffffff,
            transparent:true,
            opacity:0.8,
            depthWrite:false,
            blending:THREE.AdditiveBlending
        });
        const points = new THREE.Points(starsGeo, starsMat);
        points.userData = {speed: speedRange[0] + Math.random()*(speedRange[1]-speedRange[0]), baseOpacities};
        scene.add(points);
        return points;
    }

    starLayers = [
        createStarField(12000,120,0.5,1.2,[0.5,0.8]),
        createStarField(10000,130,0.8,1.5,[0.7,1.0]),
        createStarField(8000,140,1.0,2.0,[0.9,1.3])
    ];

    renderer = new THREE.WebGPURenderer({canvas:document.querySelector('#bg-canvas'), antialias:true});
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setAnimationLoop(animate);
}

// Funciones para el panel de loading
function showLoadingPanel(cityName) {
    loadingPanel = document.getElementById('loading-panel');
    loadingTitle = document.getElementById('loading-title');
    loadingMessage = document.getElementById('loading-message');
    loadingDetail = document.getElementById('loading-detail');
    
    // Asegurar que la UI principal est√© completamente oculta
    mainUI.style.opacity = '0';
    mainUI.style.pointerEvents = 'none'; // Deshabilitar interacciones
    
    // Mensajes din√°micos basados en la ciudad
    const messages = getLoadingMessages(cityName);
    
    loadingTitle.textContent = messages.title;
    loadingMessage.textContent = messages.message;
    loadingDetail.textContent = messages.detail;
    
    // Mostrar panel
    loadingPanel.classList.remove('hidden');
    loadingPanel.style.transition = `opacity ${fadeDurationIn}ms ease-in-out`;
    loadingPanel.style.opacity = '0';
    setTimeout(() => {
        loadingPanel.style.opacity = '1';
    }, 10);
    
    // Iniciar mensajes din√°micos
    startLoadingProgress();
}

function getLoadingMessages(cityName) {
    const cityDisplayName = capitalizeCityName(cityName);
    
    const messageSets = [
        // Mensajes de inicio - Exploraci√≥n espacial
        {
            title: "üöÄ Iniciando secuencia de lanzamiento...",
            message: "Despegando hacia el espacio...",
            detail: "Activando propulsores principales..."
        },
        {
            title: "üåç Escaneando la Tierra desde el espacio...",
            message: "Localizando tu destino en el planeta...",
            detail: "Sat√©lites GPS sincronizados ‚úÖ"
        },
        {
            title: "üõ∞Ô∏è Conectando con la red de sat√©lites...",
            message: "Estableciendo comunicaci√≥n orbital...",
            detail: "Se√±al fuerte desde la Estaci√≥n Espacial Internacional"
        },
        
        // Mensajes de navegaci√≥n - Viaje
        {
            title: "üß≠ Calculando trayectoria √≥ptima...",
            message: `Navegando hacia ${cityDisplayName}...`,
            detail: "Evitando tormentas espaciales..."
        },
        {
            title: "‚ö° Activando motores de crucero...",
            message: `Viajando a velocidad warp hacia ${cityDisplayName}...`,
            detail: "Velocidad: 28,000 km/h"
        },
        {
            title: "üåå Cruzando el espacio-tiempo...",
            message: `Teletransport√°ndonos a ${cityDisplayName}...`,
            detail: "Distorsi√≥n temporal: 0.003 segundos"
        },
        {
            title: "üéØ Ajustando coordenadas precisas...",
            message: `Apuntando hacia ${cityDisplayName}...`,
            detail: "Precisi√≥n: ¬±0.001 grados"
        },
        
        // Mensajes de an√°lisis - Datos
        {
            title: "üì° Descargando datos meteorol√≥gicos...",
            message: `Analizando clima de ${cityDisplayName}...`,
            detail: "Procesando 2.3 TB de informaci√≥n..."
        },
        {
            title: "üå°Ô∏è Escaneando patrones clim√°ticos...",
            message: `Estudiando la atm√≥sfera de ${cityDisplayName}...`,
            detail: "IA meteorol√≥gica trabajando..."
        },
        {
            title: "‚òÅÔ∏è Mapeando sistemas de nubes...",
            message: `Observando el cielo de ${cityDisplayName}...`,
            detail: "Resoluci√≥n: 4K ultra HD"
        },
        {
            title: "üå™Ô∏è Detectando corrientes de aire...",
            message: `Monitoreando vientos en ${cityDisplayName}...`,
            detail: "Sensores ultras√≥nicos activos"
        },
        
        // Mensajes de preparaci√≥n - Finalizaci√≥n
        {
            title: "üé¨ Preparando vista cinematogr√°fica...",
            message: `Optimizando visualizaci√≥n de ${cityDisplayName}...`,
            detail: "Renderizando en tiempo real..."
        },
        {
            title: "‚ú® Aplicando efectos especiales...",
            message: `Pulindo la vista de ${cityDisplayName}...`,
            detail: "Filtros atmosf√©ricos activados"
        },
        {
            title: "üéØ Enfocando objetivo principal...",
            message: `Centrando c√°mara en ${cityDisplayName}...`,
            detail: "Estabilizaci√≥n √≥ptica completa"
        },
        {
            title: "üöÄ Preparando aterrizaje suave...",
            message: `Descendiendo hacia ${cityDisplayName}...`,
            detail: "Tren de aterrizaje desplegado"
        },
        
        // Mensajes especiales por ciudad
        {
            title: "üóº Escaneando la Torre Eiffel...",
            message: "Par√≠s detectada en el horizonte...",
            detail: "Se√±al de croissants frescos recibida ü•ê"
        },
        {
            title: "üè∞ Localizando el Big Ben...",
            message: "Londres identificada por su acento...",
            detail: "T√© de las 5 en punto confirmado ‚òï"
        },
        {
            title: "üóæ Detectando el Monte Fuji...",
            message: "Tokio localizada por su tecnolog√≠a...",
            detail: "Robots de servicio activos ü§ñ"
        },
        {
            title: "üóΩ Escaneando la Estatua de la Libertad...",
            message: "Nueva York identificada por su energ√≠a...",
            detail: "Taxi amarillo detectado üöï"
        },
        {
            title: "üèõÔ∏è Localizando las pir√°mides...",
            message: "El Cairo encontrado en el desierto...",
            detail: "Momias verificando datos üìú"
        },
        {
            title: "üèñÔ∏è Detectando playas de Copacabana...",
            message: "R√≠o de Janeiro localizada por su samba...",
            detail: "Carnaval en modo standby üé≠"
        },
        {
            title: "üåÆ Escaneando tacos aut√©nticos...",
            message: "Ciudad de M√©xico identificada...",
            detail: "Salsa picante nivel m√°ximo üå∂Ô∏è"
        },
        {
            title: "ü¶ò Detectando canguros saltarines...",
            message: "S√≠dney localizada en Ocean√≠a...",
            detail: "Opera House sintonizada üé≠"
        }
    ];
    
    // Filtrar mensajes espec√≠ficos de la ciudad si existen
    const citySpecificMessages = messageSets.filter(msg => 
        msg.message.includes(cityDisplayName) || 
        msg.title.toLowerCase().includes(cityName.toLowerCase())
    );
    
    // Si hay mensajes espec√≠ficos de la ciudad, usar uno de esos
    if (citySpecificMessages.length > 0) {
        return citySpecificMessages[Math.floor(Math.random() * citySpecificMessages.length)];
    }
    
    // Si no, usar cualquier mensaje aleatorio
    return messageSets[Math.floor(Math.random() * messageSets.length)];
}

function capitalizeCityName(cityName) {
    const cityMap = {
        'tokio': 'Tokio',
        'paris': 'Par√≠s',
        'londres': 'Londres',
        'new york': 'Nueva York',
        'sydney': 'S√≠dney',
        'el cairo': 'El Cairo',
        'rio de janeiro': 'R√≠o de Janeiro',
        'mexico': 'Ciudad de M√©xico'
    };
    
    return cityMap[cityName.toLowerCase()] || cityName.charAt(0).toUpperCase() + cityName.slice(1);
}

function startLoadingProgress() {
    // Cambiar mensajes din√°micamente durante la carga
    const messageChangeInterval = 2000; // Cambiar cada 2 segundos
    
    // Cambiar mensajes din√°micamente
    const messageTimer = setInterval(() => {
        if (loadingTitle && loadingMessage && loadingDetail) {
            const currentCity = forecastRequest ? forecastRequest.city : "tokio";
            const newMessages = getLoadingMessages(currentCity);
            
            // Animaci√≥n de fade out/in para cambio suave
            loadingTitle.style.transition = "opacity 0.3s ease";
            loadingMessage.style.transition = "opacity 0.3s ease";
            loadingDetail.style.transition = "opacity 0.3s ease";
            
            loadingTitle.style.opacity = "0";
            loadingMessage.style.opacity = "0";
            loadingDetail.style.opacity = "0";
            
            setTimeout(() => {
                loadingTitle.textContent = newMessages.title;
                loadingMessage.textContent = newMessages.message;
                loadingDetail.textContent = newMessages.detail;
                
                loadingTitle.style.opacity = "1";
                loadingMessage.style.opacity = "1";
                loadingDetail.style.opacity = "1";
            }, 300);
        }
    }, messageChangeInterval);
    
    // Limpiar el timer cuando se oculte el panel
    window.currentMessageTimer = messageTimer;
}


function hideLoadingPanel() {
    if (loadingPanel) {
        loadingPanel.style.transition = `opacity ${fadeDurationOut}ms ease-in-out`;
        loadingPanel.style.opacity = '0';
        setTimeout(() => {
            loadingPanel.classList.add('hidden');
            // Limpiar solo el timer de mensajes, el progreso se maneja con requestAnimationFrame
            if (window.currentMessageTimer) {
                clearInterval(window.currentMessageTimer);
                window.currentMessageTimer = null;
            }
        }, fadeDurationOut);
    }
}

function onWindowResize(){
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate(){
    const delta = clock.getDelta();
    // Ruleta: si est√° activa, controla la rotaci√≥n Y del globo
    if(rouletteState && rouletteState.active){
        const now = performance.now();
        const t = Math.min(1, (now - rouletteState.startTime) / rouletteState.durationMs);
        // Ease-out c√∫bico para salida r√°pida inicial y desaceleraci√≥n progresiva
        const easeOutCubic = (u)=> 1 - Math.pow(1 - u, 3);
        const f = easeOutCubic(t);

        // Giro base con vueltas extra
        const baseYaw = rouletteState.initialYaw + rouletteState.extraSpin * f;

        // Rotaci√≥n simple: solo las vueltas de ruleta, sin alineaci√≥n compleja
        globe.rotation.y = baseYaw;
        if(t >= 1){
            rouletteState.active = false;
            // Termina la animaci√≥n con la rotaci√≥n final
            globe.rotation.y = baseYaw;
            const res = rouletteState.resolve; rouletteState.resolve = null;
            if(res) res();
        }
    } else if(!forecastRequest) {
        globe.rotation.y += delta*0.1;
    }

    // Elegir suavidad seg√∫n el estado
    const smoothing = forecastRequest ? smoothingIn : smoothingOut;
    camera.position.lerp(targetPosition, smoothing);
    camera.lookAt(0,0,0);

    const time = Date.now()*0.001;
    starLayers.forEach(layer=>{
        const base = layer.userData.baseOpacities;
        const avgOpacity = base.reduce((sum,b)=>sum+b*(0.7+0.3*Math.sin(time*layer.userData.speed+Math.random()*Math.PI)),0)/base.length;
        layer.material.opacity = avgOpacity;
    });

    renderer.render(scene,camera);
}

// --- UI ---
const form = document.getElementById('location-form');
const input = document.getElementById('location-input');
const mainUI = document.getElementById('main-ui');
const glassPanel = document.getElementById('glass-panel');
const glassClose = document.getElementById('glass-close');

const sampleBackendData = {
    city:'Par√≠s', lat:48.8566, lon:2.3522,
    temperature:18, precipitation:30,
    gemini:'Tendencia a cielos despejados en las pr√≥ximas horas.'
};

function showGlassPanel(data, timeInfo = null){
    document.getElementById('glass-location').textContent = data.city;
    document.getElementById('glass-coordinates').textContent = `Lat: ${data.lat.toFixed(4)}, Lon: ${data.lon.toFixed(4)}`;
    
    // Enhanced weather display with real-time data
    let forecastHTML = `
        <div class="weather-grid">
            <div class="weather-item">
                <div class="weather-icon">üå°Ô∏è</div>
                <div class="weather-value">${data.temperature}¬∞C</div>
                <div class="weather-label">Temperatura</div>
            </div>
            <div class="weather-item">
                <div class="weather-icon">üíß</div>
                <div class="weather-value">${data.humidity || 'N/A'}%</div>
                <div class="weather-label">Humedad</div>
            </div>
            <div class="weather-item">
                <div class="weather-icon">üåßÔ∏è</div>
                <div class="weather-value">${data.precipitation}%</div>
                <div class="weather-label">Precipitaci√≥n</div>
            </div>
            <div class="weather-item">
                <div class="weather-icon">üí®</div>
                <div class="weather-value">${data.windSpeed || 'N/A'} m/s</div>
                <div class="weather-label">Viento</div>
            </div>
        </div>
        <div class="weather-description">
            <strong>Condiciones:</strong> ${data.description || 'Datos no disponibles'}
        </div>
        <div class="data-source">
            <small>${data.apiStatus === 'real' ? '‚úÖ Datos en tiempo real de OpenWeatherMap' : '‚ö†Ô∏è Datos de respaldo (API no disponible)'}</small>
        </div>
    `;
    
    document.getElementById('glass-forecast').innerHTML = forecastHTML;
    
    // Format Gemini interpretation with time information
    let geminiText = data.gemini;
    if (timeInfo) {
        const timeText = formatTimeInSpanish(timeInfo);
        const locationName = data.city || 'esta ubicaci√≥n';
        geminiText = `Pron√≥stico del tiempo ${timeText} para ${locationName}: ${data.gemini}`;
    } else {
        // If no time specified, use "Diagn√≥stico actual"
        const locationName = data.city || 'esta ubicaci√≥n';
        geminiText = `Diagn√≥stico actual para ${locationName}: ${data.gemini}`;
    }
    document.getElementById('glass-gemini').textContent = `Interpretaci√≥n Gemini: ${geminiText}`;
    
    glassPanel.classList.remove('hidden');
    glassPanel.style.transition = `opacity ${fadeDurationIn}ms ease-in-out`;
    glassPanel.style.opacity='0';
    setTimeout(()=>{glassPanel.style.opacity='1';},10);
}

glassClose.addEventListener('click', () => {
    glassPanel.style.transition = `opacity ${fadeDurationOut}ms ease-in-out`;
    glassPanel.style.opacity='0';
    mainUI.style.opacity = '1';
    mainUI.style.pointerEvents = 'auto'; // Restaurar interacciones
    forecastRequest = null;
    targetPosition.set(0,0,5);
    setTimeout(()=> glassPanel.classList.add('hidden'), fadeDurationOut);
});

const cityCoordinates = {
    'tokio':{lat:35.6762, lon:139.6503},
    'paris':{lat:48.8566, lon:2.3522},
    'londres':{lat:51.5074, lon:-0.1278},
    'new york':{lat:40.7128, lon:-74.0060},
    'sydney':{lat:-33.8688, lon:151.2093},
    'el cairo':{lat:30.0444, lon:31.2357},
    'rio de janeiro':{lat:-22.9068, lon:-43.1729},
    'mexico':{lat:19.4326, lon:-99.1332}
};

// Function to format time information in Spanish
function formatTimeInSpanish(timeInfo) {
    if (!timeInfo) return '';
    
    const { type, value, original } = timeInfo;
    
    switch (type) {
        case 'days':
            if (value === 1) return 'en 1 d√≠a';
            return `en ${value} d√≠as`;
            
        case 'weeks':
            if (value === 1) return 'en 1 semana';
            return `en ${value} semanas`;
            
        case 'months':
            if (value === 1) return 'en 1 mes';
            return `en ${value} meses`;
            
        case 'years':
            if (value === 1) return 'en 1 a√±o';
            return `en ${value} a√±os`;
            
        case 'tomorrow':
            return 'ma√±ana';
            
        case 'today':
            return 'hoy';
            
        case 'next_month':
            return 'el pr√≥ximo mes';
            
        case 'next_week':
            return 'la pr√≥xima semana';
            
        case 'soon':
            return 'pronto';
            
        case 'later':
            return 'despu√©s';
            
        default:
            return original || '';
    }
}

// Function to extract both location and time from user input
function extractLocationAndTime(text) {
    // Convert to lowercase for easier matching
    const lowerText = text.toLowerCase();
    
    // List of time-related words and patterns
    const timePatterns = [
        // Days
        { pattern: /(\d+)\s*d√≠as?/i, type: 'days', value: (match) => parseInt(match[1]) },
        { pattern: /(\d+)\s*d/i, type: 'days', value: (match) => parseInt(match[1]) },
        
        // Weeks
        { pattern: /(\d+)\s*semanas?/i, type: 'weeks', value: (match) => parseInt(match[1]) },
        { pattern: /(\d+)\s*s/i, type: 'weeks', value: (match) => parseInt(match[1]) },
        
        // Months
        { pattern: /(\d+)\s*meses?/i, type: 'months', value: (match) => parseInt(match[1]) },
        { pattern: /(\d+)\s*m/i, type: 'months', value: (match) => parseInt(match[1]) },
        
        // Years
        { pattern: /(\d+)\s*a√±os?/i, type: 'years', value: (match) => parseInt(match[1]) },
        { pattern: /(\d+)\s*a/i, type: 'years', value: (match) => parseInt(match[1]) },
        
        // Specific time words
        { pattern: /ma√±ana/i, type: 'tomorrow', value: () => 1 },
        { pattern: /hoy/i, type: 'today', value: () => 0 },
        { pattern: /pr√≥ximo\s*mes/i, type: 'next_month', value: () => 1 },
        { pattern: /siguiente\s*mes/i, type: 'next_month', value: () => 1 },
        { pattern: /pr√≥xima\s*semana/i, type: 'next_week', value: () => 1 },
        { pattern: /siguiente\s*semana/i, type: 'next_week', value: () => 1 },
        { pattern: /pronto/i, type: 'soon', value: () => 3 },
        { pattern: /despu√©s/i, type: 'later', value: () => 7 }
    ];
    
    // Find time information
    let timeInfo = null;
    for (const timePattern of timePatterns) {
        const match = text.match(timePattern.pattern);
        if (match) {
            timeInfo = {
                type: timePattern.type,
                value: timePattern.value(match),
                original: match[0]
            };
            break;
        }
    }
    
    // Extract location (same logic as before)
    const location = extractLocationFromText(text);
    
    return {
        location: location,
        time: timeInfo
    };
}

// Function to extract city/country from user input
function extractLocationFromText(text) {
    // Convert to lowercase for easier matching
    const lowerText = text.toLowerCase();
    
    // List of common time-related words to ignore
    const timeWords = [
        'en', 'dentro de', 'para', 'el', 'la', 'los', 'las',
        'd√≠as', 'd√≠a', 'semanas', 'semana', 'meses', 'mes', 'a√±os', 'a√±o',
        'ma√±ana', 'hoy', 'ayer', 'pasado', 'pr√≥ximo', 'siguiente',
        'futuro', 'pronto', 'despu√©s', 'luego', 'cuando', 'si',
        'voy', 'ir√©', 'estar√©', 'visitar√©', 'viajar√©', 'ir', 'estar',
        'visitar', 'viajar', 'quiero', 'necesito', 'busco', 'buscar',
        'pron√≥stico', 'clima', 'tiempo', 'weather', 'forecast',
        'cu√°l', 'como', 'est√°', 'ser√°', 'estar√°', 'hace', 'har√°',
        'quiero', 'necesito', 'busco', 'buscar', 'ver', 'mirar',
        'saber', 'conocer', 'informaci√≥n', 'datos', 'estado',
        'condiciones', 'temperatura', 'lluvia', 'sol', 'nubes'
    ];
    
    // Remove common punctuation
    let cleanText = text.replace(/[.,!?;:()]/g, ' ');
    
    // Split into words and filter out time-related words
    let words = cleanText.toLowerCase().split(/\s+/)
        .filter(word => word.length > 0)
        .filter(word => !timeWords.includes(word))
        .filter(word => !/^\d+$/.test(word)) // Remove pure numbers
        .filter(word => !['de', 'del', 'la', 'el', 'los', 'las', 'un', 'una'].includes(word)); // Remove articles
    
    // Try to find city/country patterns
    let location = '';
    
    // Pattern 1: Single word (likely city name)
    if (words.length === 1) {
        location = words[0];
    }
    // Pattern 2: Two words (likely "City Country" or "City State")
    else if (words.length === 2) {
        location = words.join(' ');
    }
    // Pattern 3: Multiple words - try to find the most likely location
    else if (words.length > 2) {
        // Look for common city/country patterns
        const patterns = [
            // "Ciudad, Pa√≠s" pattern
            /^([^,]+),\s*(.+)$/,
            // "Ciudad Pa√≠s" pattern
            /^(.+?)\s+(.+)$/
        ];
        
        let found = false;
        for (const pattern of patterns) {
            const match = text.match(pattern);
            if (match) {
                location = match[1].trim();
                found = true;
                break;
            }
        }
        
        // If no pattern found, try to extract the first meaningful words
        if (!found) {
            // Take first 1-2 words that are likely location names
            const meaningfulWords = words.filter(word => 
                word.length > 2 && // At least 3 characters
                !['con', 'para', 'por', 'desde', 'hasta', 'entre'].includes(word)
            );
            
            if (meaningfulWords.length >= 2) {
                location = meaningfulWords.slice(0, 2).join(' ');
            } else if (meaningfulWords.length === 1) {
                location = meaningfulWords[0];
            } else {
                location = words.slice(0, 2).join(' ');
            }
        }
    }
    
    // Clean up the location
    location = location.trim();
    
    // Handle special cases for multi-word cities
    const specialCases = {
        'buenos aires': 'Buenos Aires',
        'nueva york': 'New York',
        'los angeles': 'Los Angeles',
        'san francisco': 'San Francisco',
        'las vegas': 'Las Vegas',
        'rio de janeiro': 'Rio de Janeiro',
        'sao paulo': 'Sao Paulo',
        'el cairo': 'Cairo',
        'san diego': 'San Diego',
        'san antonio': 'San Antonio',
        'santa fe': 'Santa Fe',
        'la paz': 'La Paz',
        'san jose': 'San Jose',
        'santa cruz': 'Santa Cruz',
        'san miguel': 'San Miguel',
        'santa rosa': 'Santa Rosa',
        'san luis': 'San Luis',
        'santa marta': 'Santa Marta',
        'san salvador': 'San Salvador',
        'santa clara': 'Santa Clara'
    };
    
    // Check for special cases first
    const lowerLocation = location.toLowerCase();
    if (specialCases[lowerLocation]) {
        location = specialCases[lowerLocation];
    } else {
        // Capitalize properly for regular cases
        location = location.split(' ').map(word => 
            word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
        ).join(' ');
    }
    
    console.log(`üîç Extracted location from "${text}": "${location}"`);
    return location;
}

// Geocoding function to convert any location text to coordinates
async function geocodeLocation(query) {
    try {
    const apiKey = (typeof window !== 'undefined' && window.__ENV__ && window.__ENV__.OPENWEATHER_API_KEY) || '';
        const response = await fetch(`https://api.openweathermap.org/geo/1.0/direct?q=${encodeURIComponent(query)}&limit=1&appid=${apiKey}`);
        
        if (!response.ok) {
            throw new Error(`Geocoding API Error: ${response.status}`);
        }
        
        const data = await response.json();
        console.log('üåç Geocoding result:', data);
        
        if (data && data.length > 0) {
            return {
                lat: data[0].lat,
                lon: data[0].lon,
                name: data[0].name,
                country: data[0].country,
                state: data[0].state
            };
        } else {
            throw new Error('Location not found');
        }
    } catch (error) {
        console.log('‚ö†Ô∏è Geocoding failed:', error.message);
        return null;
    }
}

form.addEventListener('submit', async (e) => {
    e.preventDefault();
    const query = input.value.trim();
    if (!query) return;
    
    // Extract both location and time from the user's text
    const extractedData = extractLocationAndTime(query);
    const extractedLocation = extractedData.location;
    const timeInfo = extractedData.time;
    
    console.log(`üìç Original query: "${query}"`);
    console.log(`üìç Extracted location: "${extractedLocation}"`);
    console.log(`‚è∞ Extracted time:`, timeInfo);
    
    // Try to find in predefined cities first (for faster response)
    const foundCity = Object.keys(cityCoordinates).find(city => 
        extractedLocation.toLowerCase().includes(city) || 
        city.includes(extractedLocation.toLowerCase())
    );
    
    let locationData;
    if (foundCity) {
        // Use predefined coordinates for known cities
        const { lat, lon } = cityCoordinates[foundCity];
        locationData = { lat, lon, name: foundCity };
        console.log('üìç Using predefined coordinates for:', foundCity);
    } else {
        // Use geocoding API for any other location
        console.log('üîç Searching for location:', extractedLocation);
        locationData = await geocodeLocation(extractedLocation);
        
        if (!locationData) {
            alert('No se pudo encontrar esa ubicaci√≥n. Intenta con otro nombre.');
            return;
        }
    }
    
    // Limpia cualquier timeout previo
    if (pendingZoomTimeout) { 
        clearTimeout(pendingZoomTimeout); 
        pendingZoomTimeout = null; 
    }

        const durationMs = 10000; // 10 segundos para dar tiempo al backend
    // Inicia ruleta PRIMERO
    const p = startRouletteAnimation(locationData.lat, locationData.lon, { durationMs, extraTurns: 6 });
    
    // MOSTRAR panel de loading DESPU√âS de iniciar la ruleta (para sincronizaci√≥n)
    setTimeout(() => {
        showLoadingPanel(locationData.name);
    }, 100); // Aumentado el delay para asegurar transici√≥n limpia
    
        // Inicia zoom ~2.5s antes del fin para un enlace m√°s suave
        const earlyMs = 2500;
    pendingZoomTimeout = setTimeout(() => {
            pendingZoomTimeout = null;
        hideLoadingPanel(); // Ocultar panel de loading
        zoomToLocation(locationData.lat, locationData.lon, locationData.name, timeInfo);
        }, Math.max(0, durationMs - earlyMs));
    p.then(() => { /* no-op: zoom ya disparado antes */ });
    forecastRequest = { city: locationData.name, query };
    
    // Ocultar UI principal inmediatamente
    mainUI.style.opacity = '0';
});

// Texture alignment offset - ajusta este valor para que coincida con tu textura de la Tierra
// Offset correcto encontrado: 90¬∞ - M√©xico aparece en Norteam√©rica, Tokyo en Jap√≥n
let earthYawOffsetDeg = -240; // Offset correcto que funciona
function latLonToVector3(lat, lon, radius){
    // Conversi√≥n est√°ndar con offset de textura: lon=0¬∞(+offset) hacia +Z
    const latRad = lat * Math.PI / 180;
    const lonRad = (lon + earthYawOffsetDeg) * Math.PI / 180;
    const cosLat = Math.cos(latRad);
    return new THREE.Vector3(
        radius * cosLat * Math.sin(lonRad), // X
        radius * Math.sin(latRad),          // Y
        radius * cosLat * Math.cos(lonRad)  // Z
    );
}

// Fetch real-time weather data
async function fetchWeatherData(lat, lon) {
    try {
        // Using OpenWeatherMap API (free tier) - replace with your API key
        const apiKey = (typeof window !== 'undefined' && window.__ENV__ && window.__ENV__.OPENWEATHER_API_KEY) || '';
        if (!apiKey) {
            console.warn('OpenWeatherMap API key is not set. Set window.__ENV__.OPENWEATHER_API_KEY or use a .env / hosting secret. Falling back to local mock data.');
        }
        const response = await fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=${apiKey}&units=metric`);
        
        if (!response.ok) {
            throw new Error(`API Error: ${response.status}`);
        }
        
        const data = await response.json();
        console.log('‚úÖ Datos reales obtenidos de OpenWeatherMap:', data);
        
        return {
            temperature: Math.round(data.main.temp),
            precipitation: data.rain ? Math.round(data.rain['1h'] || 0) : 0,
            description: data.weather[0].description,
            humidity: data.main.humidity,
            windSpeed: Math.round(data.wind.speed * 10) / 10, // Round to 1 decimal
            apiStatus: 'real'
        };
    } catch (error) {
        console.log('‚ö†Ô∏è Usando datos de respaldo:', error.message);
        // Fallback to realistic random data based on location
        const baseTemp = lat > 0 ? 20 : 15; // Northern hemisphere warmer
        const seasonalVariation = Math.sin(Date.now() / (365.25 * 24 * 60 * 60 * 1000)) * 10;
        return {
            temperature: Math.round(baseTemp + seasonalVariation + (Math.random() - 0.5) * 10),
            precipitation: Math.round(Math.random() * 80),
            description: ['clear sky', 'few clouds', 'scattered clouds', 'broken clouds', 'shower rain'][Math.floor(Math.random() * 5)],
            humidity: Math.round(40 + Math.random() * 40),
            windSpeed: Math.round(Math.random() * 15),
            apiStatus: 'fallback'
        };
    }
}

async function zoomToLocation(lat, lon, cityName, timeInfo = null){
    const target3D = latLonToVector3(lat, lon, 1);
    
    // Aplica la rotaci√≥n actual del globo al punto objetivo
    const rotatedTarget = rotateXZByYaw(target3D, globe.rotation.y);
    
    // Posiciona la c√°mara relativa al punto objetivo rotado con menos zoom
    const cameraOffset = rotatedTarget.clone().normalize().multiplyScalar(2); // Aumentado de 2.5 a 3.5 para menos zoom
    targetPosition.copy(cameraOffset);
    
    // Fetch real-time weather data
    const weatherData = await fetchWeatherData(lat, lon);
    
    // Create dynamic data based on the searched city with real weather
    const dynamicData = {
        city: cityName,
        lat: lat,
        lon: lon,
        temperature: weatherData.temperature,
        precipitation: weatherData.precipitation,
        humidity: weatherData.humidity,
        windSpeed: weatherData.windSpeed,
        description: weatherData.description,
        apiStatus: weatherData.apiStatus,
        gemini: `${weatherData.description}, temperatura ${weatherData.temperature}¬∞C, humedad ${weatherData.humidity}%.`
    };
    
    showGlassPanel(dynamicData, timeInfo);
}

window.addEventListener('resize', onWindowResize);

// ---------------------------
// Animaci√≥n tipo ruleta (API)
// ---------------------------
// Calcula el √°ngulo azimutal (XZ) de un vector
function getAzimuthXZ(v){
    return Math.atan2(v.x, v.z);
}

// Aplica rotaci√≥n Y a un vector (solo XZ)
function rotateXZByYaw(vec, yaw){
    const c = Math.cos(yaw), s = Math.sin(yaw);
    return new THREE.Vector3(
        vec.x * c + vec.z * s,
        vec.y,
        -vec.x * s + vec.z * c
    );
}

// Normaliza √°ngulo a [-PI, PI]
function normalizeAngleSigned(a){
    let ang = (a + Math.PI) % (2*Math.PI);
    if(ang < 0) ang += 2*Math.PI;
    return ang - Math.PI;
}

// Convierte a [0, 2PI)
function normalizeAnglePositive(a){
    let ang = a % (2*Math.PI);
    if(ang < 0) ang += 2*Math.PI;
    return ang;
}

// Inicia la animaci√≥n de ruleta hasta una lat/lon objetivo
// options: { durationMs=7000, extraTurns=6, direction='auto'|'cw'|'ccw' }
function startRouletteAnimation(targetLat, targetLon, options={}){
    const durationMs = options.durationMs ?? 7000;
    const extraTurns = Math.max(0, options.extraTurns ?? 6);
    const direction = options.direction ?? 'auto'; // 'cw' => +Y, 'ccw' => -Y

    // Cancela/resolve una animaci√≥n previa si existiese
    if(rouletteState && rouletteState.active && rouletteState.resolve){
        const prevResolve = rouletteState.resolve; rouletteState.active = false; rouletteState.resolve = null; prevResolve();
    }

    // Punto objetivo en el globo (sin rotaci√≥n aplicada)
    const targetPointLocal = latLonToVector3(targetLat, targetLon, 1);

    // Azimut deseado: usa la orientaci√≥n real de la c√°mara
    const viewDir = new THREE.Vector3().copy(camera.position).normalize().multiplyScalar(-1); // hacia -camera.position
    const desiredAzimuth = getAzimuthXZ(viewDir);

    // Azimut actual del punto objetivo en mundo con la rotaci√≥n actual del globo
    const currentYaw = globe.rotation.y;
    const targetPointWorld = rotateXZByYaw(targetPointLocal, currentYaw);
    const currentAzimuthWorld = getAzimuthXZ(targetPointWorld);

    // Diferencia m√≠nima necesaria para alinear el punto con el azimut deseado
    const deltaToAlign = normalizeAngleSigned(desiredAzimuth - currentAzimuthWorld);

    // Decide el signo/direcci√≥n de giro y suma vueltas extra para efecto "ruleta"
    // SIEMPRE gira hacia la derecha (sentido horario) sin importar la distancia
    let sign = 1; // Siempre positivo = siempre hacia la derecha

    const fullTurns = extraTurns * 2 * Math.PI * sign;
    const extraSpin = fullTurns; // correcci√≥n din√°mica se aplica en cada frame

    // Prepara estado
    let extResolve;
    const promise = new Promise((resolve)=>{ extResolve = resolve; });
    rouletteState = {
        active:true,
        startTime: performance.now(),
        durationMs,
        initialYaw: currentYaw,
        extraSpin,
        targetLat,
        targetLon,
        targetLocal: targetPointLocal,
        resolve: extResolve
    };

    return promise;
}

// Final offset testing based on the complete pattern
window.findPreciseOffset = function() {
    console.log("=== PRECISE OFFSET TESTING ===");
    console.log("Pattern observed:");
    console.log("- London (UK) ‚Üí appearing in Russia");
    console.log("- Tokyo (Japan) ‚Üí appearing in Mexico");
    console.log("This suggests ~90-120¬∞ rotation needed");
    
    // Test more precise offsets around the likely range
    const offsets = [90, 100, 110, 120, 130, -90, -100, -110, -120, -130];
    let currentIndex = 0;
    
    function testNext() {
        if (currentIndex >= offsets.length) {
            console.log("All precise offsets tested. Which one shows London in UK and Tokyo in Japan?");
            return;
        }
        
        const offset = offsets[currentIndex];
        console.log(`\n=== Testing precise offset: ${offset}¬∞ ===`);
        testTextureOffset(offset, "londres");
        
        currentIndex++;
        setTimeout(testNext, 4000); // Wait 4 seconds between tests
    }
    
    testNext();
};

// Quick test function to find the right offset
window.findCorrectOffset = function() {
    console.log("Testing different offsets for London...");
    console.log("London should appear in the UK (Europe), not in the US");
    
    const offsets = [0, 90, -90, 180, -180, 270, -270];
    let currentIndex = 0;
    
    function testNext() {
        if (currentIndex >= offsets.length) {
            console.log("All offsets tested. Which one showed London in the correct location?");
            return;
        }
        
        const offset = offsets[currentIndex];
        console.log(`\n=== Testing offset: ${offset}¬∞ ===`);
        testTextureOffset(offset, "londres");
        
        currentIndex++;
        setTimeout(testNext, 3000); // Wait 3 seconds between tests
    }
    
    testNext();
};

// Quick manual tests for common offsets
window.quickTestOffsets = function() {
    console.log("=== QUICK MANUAL TESTS ===");
    console.log("Try these common offsets manually:");
    console.log("testTextureOffset(0, 'mexico')     - No offset");
    console.log("testTextureOffset(90, 'mexico')    - 90¬∞ clockwise");
    console.log("testTextureOffset(180, 'mexico')   - 180¬∞ clockwise");
    console.log("testTextureOffset(270, 'mexico')   - 270¬∞ clockwise");
    console.log("testTextureOffset(-90, 'mexico')   - 90¬∞ counter-clockwise");
    console.log("testTextureOffset(-180, 'mexico')  - 180¬∞ counter-clockwise");
    console.log("testTextureOffset(-270, 'mexico')  - 270¬∞ counter-clockwise");
    console.log("\nMexico should appear in North America (left side of texture)");
};

// Systematic testing of all possible offsets
window.testAllOffsets = function() {
    console.log("=== SYSTEMATIC OFFSET TESTING ===");
    console.log("Testing every 30¬∞ from 0¬∞ to 360¬∞ to find the correct offset");
    console.log("Mexico should appear in North America, not Africa");
    
    const offsets = [0, 30, 60, 90, 120, 150, 180, 210, 240, 270, 300, 330];
    let currentIndex = 0;
    
    function testNext() {
        if (currentIndex >= offsets.length) {
            console.log("All systematic offsets tested. Which one shows Mexico in North America?");
            return;
        }
        
        const offset = offsets[currentIndex];
        console.log(`\n=== Testing systematic offset: ${offset}¬∞ ===`);
        testTextureOffset(offset, "mexico");
        
        currentIndex++;
        setTimeout(testNext, 5000); // Wait 5 seconds between tests
    }
    
    testNext();
};

// Quick test for the most likely offset based on pattern
window.testMostLikelyOffset = function() {
    console.log("Testing the most likely offset: 140¬∞");
    console.log("This should fix:");
    console.log("- Mexico: Africa ‚Üí North America");
    console.log("- Tokyo: Mexico ‚Üí Japan"); 
    console.log("- London: Russia ‚Üí UK");
    
    testBothCities(140);
};

// Final offset testing based on the complete pattern
window.findFinalOffset = function() {
    console.log("=== FINAL OFFSET TESTING ===");
    console.log("Complete pattern observed:");
    console.log("- Mexico (North America) ‚Üí appearing in Africa");
    console.log("- Tokyo (Japan) ‚Üí appearing in Mexico");
    console.log("- London (UK) ‚Üí appearing in Russia");
    console.log("This suggests ~120-150¬∞ rotation needed");
    
    // Test the most likely offsets based on the pattern
    const offsets = [120, 130, 140, 150, 160, -120, -130, -140, -150, -160];
    let currentIndex = 0;
    
    function testNext() {
        if (currentIndex >= offsets.length) {
            console.log("All final offsets tested. Which one shows all cities in correct locations?");
            return;
        }
        
        const offset = offsets[currentIndex];
        console.log(`\n=== Testing final offset: ${offset}¬∞ ===`);
        testTextureOffset(offset, "mexico");
        
        currentIndex++;
        setTimeout(testNext, 4000); // Wait 4 seconds between tests
    }
    
    testNext();
};

// Test specific texture offset with a city
window.testTextureOffset = function(offsetDeg, cityName = "londres") {
    const coords = cityCoordinates[cityName.toLowerCase()];
    if (!coords) {
        console.log(`City ${cityName} not found`);
        return;
    }
    
    console.log(`Testing texture offset ${offsetDeg}¬∞ with ${cityName}`);
    
    // Temporarily set the offset
    const originalOffset = earthYawOffsetDeg;
    earthYawOffsetDeg = offsetDeg;
    
    // Reset globe rotation
    globe.rotation.y = 0;
    
    // Navigate to the city
    zoomToLocation(coords.lat, coords.lon, cityName);
    forecastRequest = {city: cityName, query: cityName};
    mainUI.style.opacity = '0';
    
    console.log(`Applied offset ${offsetDeg}¬∞. Check if ${cityName} appears in the correct location on your texture.`);
    console.log(`To revert: adjustTextureOffset(${originalOffset})`);
};

// Test both London and Tokyo to verify the offset works for both
window.testBothCities = function(offsetDeg) {
    console.log(`Testing offset ${offsetDeg}¬∞ with both London and Tokyo`);
    
    const originalOffset = earthYawOffsetDeg;
    earthYawOffsetDeg = offsetDeg;
    globe.rotation.y = 0;
    
    // Test London first
    console.log("Testing London...");
    testTextureOffset(offsetDeg, "londres");
    
    setTimeout(() => {
        console.log("Testing Tokyo...");
        testTextureOffset(offsetDeg, "tokio");
        console.log(`\nCheck both cities: London should be in UK, Tokyo should be in Japan`);
        console.log(`If both are correct, run: adjustTextureOffset(${offsetDeg})`);
    }, 3000);
};

// Comprehensive debugging function
window.debugCoordinates = function(cityName) {
    const coords = cityCoordinates[cityName.toLowerCase()];
    if (!coords) {
        console.log(`City ${cityName} not found`);
        return;
    }
    
    console.log(`=== DEBUGGING ${cityName.toUpperCase()} ===`);
    console.log(`Original coordinates: lat=${coords.lat}, lon=${coords.lon}`);
    
    // Test different texture offsets
    const offsets = [0, -90, -180, -270, 90, 180, 270];
    
    offsets.forEach(offset => {
        const testOffset = offset;
        const latRad = coords.lat * Math.PI / 180;
        const lonRad = (coords.lon + testOffset) * Math.PI / 180;
        const cosLat = Math.cos(latRad);
        const testVector = new THREE.Vector3(
            Math.cos(latRad) * Math.sin(lonRad),
            Math.sin(latRad),
            Math.cos(latRad) * Math.cos(lonRad)
        );
        
        console.log(`Offset ${testOffset}¬∞: Vector(${testVector.x.toFixed(3)}, ${testVector.y.toFixed(3)}, ${testVector.z.toFixed(3)})`);
    });
    
    console.log(`Current globe rotation: ${globe.rotation.y.toFixed(3)} radians (${(globe.rotation.y * 180 / Math.PI).toFixed(1)}¬∞)`);
    console.log(`Current texture offset: ${earthYawOffsetDeg}¬∞`);
};

// Function to reset globe rotation for testing
window.resetGlobeRotation = function() {
    globe.rotation.y = 0;
    console.log('Globe rotation reset to 0');
};

// Funci√≥n para probar ajustes espec√≠ficos manualmente
window.testFineOffset = function(offsetDeg) {
    console.log(`Probando ajuste fino ${offsetDeg}¬∞`);
    
    // Aplicar el offset
    earthYawOffsetDeg = offsetDeg;
    
    // Reset globo
    globe.rotation.y = 0;
    targetPosition.set(0, 0, 5);
    
    // Probar con M√©xico
    console.log("Probando M√©xico...");
    zoomToLocation(19.4326, -99.1332, "M√©xico");
    forecastRequest = {city: "mexico", query: "mexico"};
    mainUI.style.opacity = '0';
    
    console.log(`Ajuste fino ${offsetDeg}¬∞ aplicado. ¬øM√©xico est√° en el lugar correcto?`);
};

// Funci√≥n para ajustes finos del offset
window.fineTuneOffset = function() {
    console.log('=== AJUSTE FINO DEL OFFSET ===');
    console.log('Offset actual: -263¬∞');
    console.log('Problema: Aparece un poco al oeste');
    console.log('Probando ajustes finos...');
    
    // Si est√° al oeste, necesitamos valores m√°s negativos (m√°s hacia el este)
    const fineAdjustments = [-265, -266, -267, -268, -270, -275];
    let currentIndex = 0;
    
    function testNext() {
        if (currentIndex >= fineAdjustments.length) {
            console.log('Todos los ajustes finos probados. ¬øCu√°l est√° en el lugar correcto?');
            return;
        }
        
        const offset = fineAdjustments[currentIndex];
        console.log(`\n=== Probando ajuste fino: ${offset}¬∞ ===`);
        
        // Aplicar el offset
        earthYawOffsetDeg = offset;
        
        // Reset globo
        globe.rotation.y = 0;
        targetPosition.set(0, 0, 5);
        
        // Probar con M√©xico
        console.log("Probando M√©xico...");
        zoomToLocation(19.4326, -99.1332, "M√©xico");
        forecastRequest = {city: "mexico", query: "mexico"};
        mainUI.style.opacity = '0';
        
        currentIndex++;
        setTimeout(testNext, 4000); // Esperar 4 segundos entre pruebas
    }
    
    testNext();
};

// Funci√≥n para probar un offset espec√≠fico manualmente
window.testOffset = function(offsetDeg) {
    console.log(`Probando offset ${offsetDeg}¬∞`);
    
    // Aplicar el offset
    earthYawOffsetDeg = offsetDeg;
    
    // Reset globo
    globe.rotation.y = 0;
    targetPosition.set(0, 0, 5);
    
    // Probar con M√©xico
    console.log("Probando M√©xico...");
    zoomToLocation(19.4326, -99.1332, "M√©xico");
    forecastRequest = {city: "mexico", query: "mexico"};
    mainUI.style.opacity = '0';
    
    console.log(`Offset ${offsetDeg}¬∞ aplicado. ¬øM√©xico aparece en Norteam√©rica?`);
};

// Funci√≥n para ajustar el nivel de zoom
window.setZoomLevel = function(distance) {
    console.log(`Configurando distancia de zoom a ${distance}`);
    
    // Actualizar la funci√≥n zoomToLocation para usar la nueva distancia
    window.zoomToLocation = function(lat, lon, cityName){
        const target3D = latLonToVector3(lat, lon, 1);
        
        // Aplica la rotaci√≥n actual del globo al punto objetivo
        const rotatedTarget = rotateXZByYaw(target3D, globe.rotation.y);
        
        // Posiciona la c√°mara relativa al punto objetivo rotado con distancia personalizada
        const cameraOffset = rotatedTarget.clone().normalize().multiplyScalar(distance);
        targetPosition.copy(cameraOffset);
        
        // Create dynamic data based on the searched city
        const dynamicData = {
            city: cityName,
            lat: lat,
            lon: lon,
            temperature: Math.round(15 + Math.random() * 20), // Random temp between 15-35¬∞C
            precipitation: Math.round(Math.random() * 100), // Random precipitation 0-100%
            gemini: `Pron√≥stico para ${cityName}: condiciones variables con tendencia a estabilizarse.`
        };
        
        showGlassPanel(dynamicData);
    };
    
    console.log(`Zoom configurado a distancia ${distance}. Prueba con una ciudad.`);
};

// Funci√≥n para alternar entre modo d√≠a solamente y modo normal
window.toggleDayOnlyMode = function() {
    console.log('Modo d√≠a solamente activado - siempre usa textura de d√≠a');
    console.log('El globo ahora siempre se ver√° iluminado sin efectos de noche');
    console.log('Para volver al modo normal, recarga la p√°gina');
};

// Funci√≥n para probar diferentes niveles de zoom
window.testZoomLevels = function() {
    console.log('=== NIVELES DE ZOOM DISPONIBLES ===');
    console.log('Distancias recomendadas:');
    console.log('- setZoomLevel(2.0) - Muy cerca (zoom m√°ximo)');
    console.log('- setZoomLevel(2.5) - Cerca');
    console.log('- setZoomLevel(3.0) - Medio');
    console.log('- setZoomLevel(3.5) - Lejos (actual)');
    console.log('- setZoomLevel(4.0) - Muy lejos');
    console.log('- setZoomLevel(5.0) - Vista general');
    console.log('');
    console.log('Prueba con: setZoomLevel(4.0)');
};

// Funci√≥n para encontrar el offset correcto autom√°ticamente
window.findCorrectOffset = function() {
    console.log("=== BUSCANDO OFFSET CORRECTO ===");
    console.log("Problema actual:");
    console.log("- Tokyo aparece en Am√©rica");
    console.log("- M√©xico aparece en √Åfrica");
    console.log("Probando diferentes offsets...");
    
    const testOffsets = [0, 90, 180, 270, -90, -180, -270];
    let currentIndex = 0;
    
    function testNext() {
        if (currentIndex >= testOffsets.length) {
            console.log("Todos los offsets probados. ¬øCu√°l mostr√≥ las coordenadas correctas?");
            return;
        }
        
        const offset = testOffsets[currentIndex];
        console.log(`\n=== Probando offset: ${offset}¬∞ ===`);
        
        // Aplicar el offset
        earthYawOffsetDeg = offset;
        
        // Reset globo
        globe.rotation.y = 0;
        targetPosition.set(0, 0, 5);
        
        // Probar con M√©xico
        console.log("Probando M√©xico...");
        zoomToLocation(19.4326, -99.1332, "M√©xico");
        forecastRequest = {city: "mexico", query: "mexico"};
        mainUI.style.opacity = '0';
        
        currentIndex++;
        setTimeout(testNext, 5000); // Esperar 5 segundos entre pruebas
    }
    
    testNext();
};

// Funci√≥n simple para probar coordenadas
window.testSimpleCoordinates = function(cityName) {
    const coords = cityCoordinates[cityName.toLowerCase()];
    if (!coords) {
        console.log(`City ${cityName} not found`);
        return;
    }
    
    console.log(`Testing simple coordinates for ${cityName}:`, coords);
    
    // Reset everything
    globe.rotation.y = 0;
    targetPosition.set(0, 0, 5);
    
    // Navigate to coordinates
    zoomToLocation(coords.lat, coords.lon, cityName);
    forecastRequest = {city: cityName, query: cityName};
    mainUI.style.opacity = '0';
    
    console.log(`Simple test for ${cityName}. Check coordinates.`);
};

// Funci√≥n para probar coordenadas sin animaci√≥n de ruleta
window.testCoordinatesDirect = function(cityName) {
    const coords = cityCoordinates[cityName.toLowerCase()];
    if (!coords) {
        console.log(`City ${cityName} not found`);
        return;
    }
    
    console.log(`Testing coordinates for ${cityName}:`, coords);
    
    // Reset globe rotation to 0
    globe.rotation.y = 0;
    
    // Navigate directly to coordinates
    zoomToLocation(coords.lat, coords.lon, cityName);
    forecastRequest = {city: cityName, query: cityName};
    mainUI.style.opacity = '0';
    
    console.log(`Direct navigation to ${cityName}. Check if coordinates are correct.`);
};

// Test function to navigate directly to coordinates without roulette animation
window.testDirectNavigation = function(cityName) {
    const coords = cityCoordinates[cityName.toLowerCase()];
    if (coords) {
        console.log(`Testing direct navigation to ${cityName}:`, coords);
        zoomToLocation(coords.lat, coords.lon, cityName);
        forecastRequest = {city: cityName, query: cityName};
        mainUI.style.opacity = '0';
    } else {
        console.log(`City ${cityName} not found in coordinates`);
    }
};

// Helper function to test texture alignment - call from browser console
// Usage: adjustTextureOffset(90) or adjustTextureOffset(-23.5)
window.adjustTextureOffset = function(offsetDeg) {
    earthYawOffsetDeg = offsetDeg;
    console.log(`Texture offset set to ${offsetDeg} degrees`);
    console.log('Test with a city to see if coordinates align better with texture');
};

// Helper function to get current offset
window.getTextureOffset = function() {
    console.log(`Current texture offset: ${earthYawOffsetDeg} degrees`);
    return earthYawOffsetDeg;
};

// Expone la API global sin tocar UI/c√°mara
window.startRouletteAnimation = startRouletteAnimation;

// Testing functions for location and time extraction
window.testLocationAndTimeExtraction = function(text) {
    const extracted = extractLocationAndTime(text);
    console.log(`Input: "${text}"`);
    console.log(`Location: "${extracted.location}"`);
    console.log(`Time:`, extracted.time);
    if (extracted.time) {
        console.log(`Formatted time: "${formatTimeInSpanish(extracted.time)}"`);
    }
    return extracted;
};

window.testTimeExtraction = function() {
    const testCases = [
        "M√©xico en 2 d√≠as",
        "Buenos Aires en 1 mes",
        "Tokio en 3 semanas",
        "Par√≠s el pr√≥ximo mes",
        "Londres en 5 d√≠as",
        "Nueva York ma√±ana",
        "Sydney en 2 semanas",
        "El Cairo en 1 a√±o",
        "R√≠o de Janeiro pronto",
        "Madrid en 6 meses",
        "Berl√≠n el siguiente mes",
        "Roma en 10 d√≠as",
        "Barcelona en 3 meses",
        "Amsterdam en 2 semanas",
        "Viena en 1 mes",
        "Tokyo tomorrow",
        "Paris next week",
        "London in 2 weeks",
        "Madrid", // Sin tiempo especificado
        "Barcelona" // Sin tiempo especificado
    ];
    
    console.log("üß™ Testing location and time extraction:");
    testCases.forEach(testCase => {
        const extracted = extractLocationAndTime(testCase);
        const timeText = extracted.time ? formatTimeInSpanish(extracted.time) : 'No time specified';
        
        // Show the final Gemini interpretation format
        let geminiFormat;
        if (extracted.time) {
            geminiFormat = `Pron√≥stico del tiempo ${timeText} para ${extracted.location}`;
        } else {
            geminiFormat = `Diagn√≥stico actual para ${extracted.location}`;
        }
        
        console.log(`"${testCase}" ‚Üí Location: "${extracted.location}", Time: "${timeText}"`);
        console.log(`  Gemini format: "${geminiFormat}"`);
    });
};

window.testMultipleLocations = function() {
    const testCases = [
        "M√©xico en 2 d√≠as",
        "Buenos Aires en 1 mes",
        "Tokio en 3 semanas",
        "Par√≠s el pr√≥ximo mes",
        "Londres en 5 d√≠as",
        "Nueva York ma√±ana",
        "Sydney en 2 semanas",
        "El Cairo en 1 a√±o",
        "R√≠o de Janeiro pronto",
        "Madrid en 6 meses",
        "Berl√≠n el siguiente mes",
        "Roma en 10 d√≠as",
        "Barcelona en 3 meses",
        "Amsterdam en 2 semanas",
        "Viena en 1 mes"
    ];
    
    console.log("üß™ Testing location extraction:");
    testCases.forEach(testCase => {
        const extracted = extractLocationFromText(testCase);
        console.log(`"${testCase}" ‚Üí "${extracted}"`);
    });
};

window.testLoadingPanel = function(cityName = "tokio") {
    console.log(`Probando panel de loading con mensajes din√°micos para ${cityName}`);
    showLoadingPanel(cityName);
    
    // Simular duraci√≥n de carga
    setTimeout(() => {
        console.log("Panel de loading funcionando perfectamente!");
        hideLoadingPanel();
    }, 10000);
};

window.showLoading = function(cityName = "paris") {
    showLoadingPanel(cityName);
};

window.hideLoading = function() {
    hideLoadingPanel();
};

// Funciones adicionales para probar mensajes din√°micos
window.testAllCities = function() {
    const cities = ['tokio', 'paris', 'londres', 'mexico', 'new york', 'sydney', 'el cairo', 'rio de janeiro'];
    let currentIndex = 0;
    
    function testNextCity() {
        if (currentIndex >= cities.length) {
            console.log("Todas las ciudades probadas. ¬°Mensajes s√∫per din√°micos!");
            return;
        }
        
        const city = cities[currentIndex];
        console.log(`Probando mensajes din√°micos para ${city}...`);
        showLoadingPanel(city);
        
        currentIndex++;
    setTimeout(() => {
        hideLoadingPanel();
            setTimeout(testNextCity, 1000);
        }, 5000);
    }
    
    testNextCity();
};

window.testRandomMessages = function(cityName = "tokio") {
    console.log(`Probando mensajes aleatorios para ${cityName}`);
    console.log("Los mensajes cambiar√°n cada 2 segundos autom√°ticamente");
    showLoadingPanel(cityName);
    
    setTimeout(() => {
        console.log("Mensajes din√°micos funcionando perfectamente!");
    hideLoadingPanel();
    }, 10000);
};
</script>
</body>
</html>